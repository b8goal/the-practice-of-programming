
# 4장 인터페이스


``` ad-quote
담을 쌓기 전부터 알고 싶었소
내가 안을 지켜 쌓는 것인지, 밖을 막아 쌓는 것인지
누군가를 해치려는 건 아닌지
무언가 담장을 좋아하지 않는 것이 있어요.
무너뜨리는 뭔가가
```

- **설계의 핵심** : 서로 대립하는 **목표**와 **제약** 사이에서 **균형**을 잡는 데 있다. 
- **설계 단계에서 다루어야 할 문제들** :
	- 인터페이스 : 
		- 어떤 *서비스*와 *접근 권한*을 제공할 것인가? 
		- 인터페이스는 서비스 제공자와 서비스 사용자 사이의 *계약*이다.
	- 정보 은닉 : 
		- 어떤 정보를 드러내고, 어떤 정보를 숨길 것인가?
		- 인터페이스는 각 컴포넌트에 이르는 분명한 *접근 경로*를 제공해야 하며, 동시에 *세부 구현*에 대한 정보는 숨겨야 한다.
	- 자원 관리 
	- 에러 처리

``` ad-info
title: 4장에서 다루는 **개념** 서로 다른 소스 파일에 존재하는 컴포넌트 간의 **인터페이스**

- 우리는 이 장에서 함수와 자료구조를 모아, 공통 작업을 처리하는 라이브러리 하나로 만들면서 인터페이스 설계를 설명할 것이다.
- 그리고 이 과정에서 인터페이스 설계를 설명할 것이다. 
- 인터페이스 설계에는 몇 가지 설계 원칙을 주의해야 한다. 
- 그렇지 않으면 매일 프로그래머들을 좌절시키는 엉망인 인터페이스가 만들어질 것이다.
```

``` ad-tip
title: Q. 개발 설계 과정에서의 인터페이스와 UI에서의 인터페이스는 어떤 점에서 다르고, 어떤 점에서 공통점이 있지?
GPT :
프로그래밍에서의 인터페이스(interface)와 UI(User Interface)에서 우리가 이야기하는 인터페이스는 다른 개념이지만 일부 공통점도 가지고 있습니다.

1. **차이점**:
    
    - *개념적 차이*: 프로그래밍에서 인터페이스는 클래스나 모듈이 제공하는 메서드와 기능의 집합을 말합니다. 이는 객체 지향 프로그래밍에서 중요한 역할을 하며, 다른 클래스와의 상호작용을 위한 규약을 정의합니다. 반면, UI(User Interface)는 사용자와 컴퓨터 시스템 간의 상호작용을 가능하게 하는 그래픽, 텍스트, 오디오 및 기타 입력 및 출력 요소들을 포함합니다.
    - *목적의 차이*: 프로그래밍 인터페이스는 다른 소프트웨어 컴포넌트들 간의 상호작용을 위해 설계되었습니다. 이는 주로 개발자들에게 중요합니다. 반면, UI는 최종 사용자가 시스템을 쉽고 효과적으로 사용할 수 있도록 설계된 사용자 경험의 일부분입니다.
2. **공통점**:
    
    - *상호작용의 매개체*: 두 인터페이스 모두 상호작용을 위한 매개체로 기능합니다. 프로그래밍 인터페이스는 다른 코드 블록이나 모듈과의 상호작용을 위한 매개체 역할을 하며, UI는 사용자와 시스템 간의 상호작용을 위한 매개체입니다.
    - *규약 및 표준의 정의*: 두 인터페이스 모두 일정한 규약이나 표준을 제공합니다. 프로그래밍 인터페이스는 어떤 메서드나 함수가 사용되어야 하는지 정의하는 반면, UI는 사용자가 어떻게 시스템과 상호작용할 수 있는지를 정의합니다.

이 두 개념은 서로 다른 목적과 역할을 가지고 있지만, 모두 사용자나 다른 시스템과의 효율적인 상호작용을 가능하게 하는 중요한 역할을 합니다.



```

---

# 4.1 콤마 구분값

- **콤마 구분값(comma-separated values, CSV)** : 표 형식의 자료를 표현하기 위해 사용되는 표현 방식.
	- 열(row)은 텍스트 한 줄이 되고, 각 줄의 필드(field)는 콤마로 구분한다. 

``` ad-tip
title: Q. CSV는 DB와 무엇이 다르지?
CSV (Comma-Separated Values) 파일과 서버에 있는 데이터베이스(DB)는 데이터를 저장하고 관리하는 방식에 있어 여러 가지 중요한 차이점이 있습니다.

1. **구조와 복잡성**:
    
    - **CSV**: 간단한 텍스트 파일 형식으로, 데이터가 콤마나 다른 구분자로 분리된 행과 열로 구성됩니다. 복잡한 구조를 표현하는 데에는 제한적이며, 주로 단순한 표 형태의 데이터를 저장하는 데 적합합니다.
    - **데이터베이스**: 더 복잡한 구조를 가지며, 관계형 데이터베이스의 경우 테이블, 행, 열, 인덱스 등을 포함할 수 있습니다. 또한, 데이터베이스는 데이터의 무결성, 동시 접근 처리, 복잡한 쿼리 실행 등 다양한 기능을 제공합니다.
2. **데이터 접근 및 관리**:
    
    - **CSV**: 파일 시스템을 통해 접근되며, 데이터베이스 관리 시스템(DBMS)이 없어 복잡한 쿼리나 트랜잭션 관리가 불가능합니다.
    - **데이터베이스**: DBMS를 통해 관리되며, SQL(Structured Query Language)과 같은 쿼리 언어를 사용하여 데이터를 검색, 수정, 삭제할 수 있습니다. 트랜잭션 관리, 동시성 제어, 백업 및 복구와 같은 고급 기능을 제공합니다.
3. **확장성과 성능**:
    
    - **CSV**: 대규모 데이터에 대한 확장성이 제한적이며, 큰 파일을 처리할 때 성능 문제가 발생할 수 있습니다.
    - **데이터베이스**: 대규모 데이터와 높은 트랜잭션 속도를 처리할 수 있도록 설계되었으며, 인덱싱, 캐싱 등을 통해 높은 성능을 제공합니다.
4. **보안**:
    
    - **CSV**: 기본적인 파일 보안 기능만을 제공하며, 복잡한 보안 요구사항을 충족시키기 어렵습니다.
    - **데이터베이스**: 사용자 권한 관리, 암호화, 감사 로그 등 보안을 위한 다양한 기능을 제공합니다.

요약하자면, CSV는 간단한 데이터 저장에 적합한 반면, 데이터베이스는 복잡하고 대규모의 데이터를 효율적으로 관리하기 위해 고안된 시스템입니다. 데이터베이스는 CSV보다 훨씬 강력한 기능과 성능을 제공하지만, 동시에 더 복잡하고 관리가 필요한 시스템입니다.
```

``` ad-tip
title: Q. 이렇게 많은 이점이 있는 DB 대신 CSV를 사용하는 이유는 뭐지?
CSV (Comma-Separated Values) 파일을 사용하는 이유는 여러 가지가 있습니다. CSV는 특정 상황에서 데이터베이스에 비해 몇 가지 중요한 이점을 제공합니다:

1. **간단함과 접근성**: CSV는 매우 간단한 구조를 가지고 있어, 텍스트 편집기를 이용해서도 쉽게 읽고 편집할 수 있습니다. 특별한 소프트웨어나 데이터베이스 시스템을 필요로 하지 않기 때문에, 데이터의 이동성과 접근성이 뛰어납니다.
    
2. **범용성**: CSV 형식은 거의 모든 종류의 데이터 관리 시스템, 스프레드시트 프로그램, 데이터 분석 도구 등에서 널리 지원되며 호환됩니다. 이로 인해 데이터 공유 및 교환에 매우 유용합니다.
    
3. **경량성**: CSV 파일은 텍스트 기반 형식이기 때문에, 파일 크기가 상대적으로 작고, 시스템 자원을 적게 소모합니다. 이는 특히 리소스가 제한된 환경에서 유리합니다.
    
4. **개발 및 통합 용이성**: 프로그래밍 언어나 스크립트를 사용하여 CSV 파일을 생성하고 파싱하는 것은 매우 간단합니다. 복잡한 데이터베이스 시스템을 구축하고 관리할 필요가 없어, 작은 프로젝트나 단일 용도의 애플리케이션에서 유용합니다.
    
5. **데이터베이스 및 기타 시스템과의 호환**: 많은 데이터베이스 시스템과 소프트웨어는 CSV 파일을 데이터의 수입(Import) 및 수출(Export) 형식으로 사용합니다. 이를 통해 다양한 시스템 간에 데이터를 쉽게 이동할 수 있습니다.
    
6. **인간 가독성**: CSV는 텍스트 기반 형식으로, 인간이 직접 읽고 이해하기 쉽습니다. 데이터의 간단한 검토나 수정을 위해 복잡한 데이터베이스 시스템을 사용할 필요가 없습니다.
    

이러한 이유로, CSV는 데이터 공유, 간단한 데이터 분석, 소규모 프로젝트, 데이터베이스와의 호환성이 필요한 경우 등에서 여전히 널리 사용됩니다. 그러나 대규모 데이터셋, 복잡한 데이터 관계, 고급 분석 및 보안이 중요한 경우에는 데이터베이스 시스템이 더 적합할 수 있습니다.
```

``` ad-tip
title: Q. DB와 CSV는 상호 보완적으로 사용하기도 하는가?
네, 맞습니다. 데이터베이스(DB)와 CSV (Comma-Separated Values) 파일은 상호 보완적으로 사용될 수 있으며, 실제로 많은 비즈니스 및 기술 환경에서 그렇게 사용되고 있습니다. 이러한 상호 보완적 사용의 몇 가지 예는 다음과 같습니다:

1. **데이터 수출 및 수입**: 데이터베이스에서 데이터를 CSV 파일 형태로 수출(Export)하여 데이터를 백업하거나, 다른 시스템으로 이동시키는 데 자주 사용됩니다. 반대로, CSV 파일 형태로 저장된 데이터를 데이터베이스에 수입(Import)하여 데이터를 데이터베이스 시스템에서 관리하고 분석할 수 있습니다.
    
2. **데이터 공유 및 교환**: 데이터베이스에 저장된 데이터를 다른 부서나 조직과 공유할 때, CSV 형식이 표준적인 방법으로 사용됩니다. CSV는 대부분의 데이터 시스템과 호환되기 때문에, 데이터 교환의 유연성을 제공합니다.
    
3. **간단한 데이터 분석 및 보고**: 복잡한 데이터베이스 쿼리나 분석 작업이 필요하지 않은 경우, 데이터를 CSV 파일로 추출하여 스프레드시트 프로그램(예: Microsoft Excel, Google Sheets)에서 간단한 데이터 분석이나 보고 작업을 수행할 수 있습니다.
    
4. **시스템 통합**: 서로 다른 시스템 간의 데이터 통합을 위해 CSV 파일을 사용하는 경우가 많습니다. 특히, 서로 다른 데이터베이스 시스템을 사용하는 경우, CSV는 범용적인 중간 형식으로 사용됩니다.
    
5. **임시 데이터 저장 및 처리**: 일시적인 데이터 처리 작업이나 임시적인 데이터 저장을 위해 CSV 파일을 사용하는 경우가 있습니다. 이는 특히 데이터베이스 시스템의 자원을 절약하고자 할 때 유용합니다.
    

이렇게 DB와 CSV를 결합하여 사용하는 방식은 데이터 관리의 유연성을 증가시키고, 다양한 요구 사항에 대응할 수 있는 강력한 방법을 제공합니다. 그러나 데이터의 무결성, 보안, 복잡한 관계 및 분석이 중요한 경우에는 데이터베이스 시스템의 이점을 최대한 활용해야 합니다.
```

---
# 4.2 프로토타입 라이브러리

- **프로토타입 라이브러리를 만들면서 주의 깊게 살펴봐야 하는 쟁점들** :
	- 이 프로토타입은 입력이 아주 길거나, 필드가 많은 경우를 처리하지 않는다. 에러가 생겼을 때 정상적인 값을 리턴하는지는 고사하고 오버플로우 검사조차 하지 않기 때문에 잘못된 결과를 내거나 죽어버릴 수도 있다.
	- 입력은 여러 줄로 구성되며, 각 줄은 개행문자로 구분된다고 가정한다.
	- 각 필드는 콤마로 구분하고, 필드를 둘러싼 따옴표는 제거한다. 필드 내용에 따옴표나 콤마가 들어가 있는 경우는 대비하지 않았다.
	- 입력 내용을 보존하지 않고, 필드를 만드는 과정에서 덮어 쓴다.
	- 한 줄을 처리하고 다음 줄로 넘어갈 때 이전 데이터를 저장하지 않는다. 만약 어떤 정보를 남기고 싶다면, 반드시 따로 복사해 두어야 한다.
	- 각 필드에 대한 접근은 전역변수인 field 배열을 통해 이루어진다. 이 배열은 csvgetline 함수와 이를 호출하는 함수들이 함께 공유하며, 필드 내용이나 포인터 접근에 대한 제어는 이루어지지 않는다. 마지막 필드 위치를 초과하는 접근을 막는 부분도 없다.
	- 전역변수 때문에 이 설계는 멀티쓰레드 환경에 맞지 않을 뿐 아니라 두 개의 호출 흐름이 번갈아 나타나는 경우에도 적합하지 않다.
	- 함수를 호출하는 쪽에서 파일을 명시적으로 열고 닫아야 한다. csvgetline은 열린 파일만 읽을 수 있다.
	- 데이터를 읽는 부분과 분리하는 부분이 한데 뭉쳐 있다. 호출할 때마다 애플리케이션의 요구와 상관없이 무조건 한 줄씩 읽고 필드 별로 분리한다.
	- 리턴 값은 그 줄에 있는 필드의 개수다. 이 값을 계산하기 위해서는 각 줄을 필드로 분리해야 한다. 또한 파일 끝에서 발생하는 에러를 구분해 낼 방법이 없다.
	- 코드를 변경하지 않고 이런 특징들을 고칠 방법은 없다. \
- **이 프로토타입은 단순한 작업에서 쓰기에는 쓸만하지만 형식이 바뀌거나, 필드가 엄청나게 많은 입력을 보내준다면 문제가 생길 가능성이 크다.**
- **이 시나리오는 수많은 부실 인터페이스의 역사를 대변하는 전형이다.**

---
# 4.3 다른 사람이 쓸 수 있는 라이브러리

- **범용으로 쓸 만한 라이브러리를 구축할 때 신경써야 할 요소들** : 
	- csvgetline 함수를 좀 더 튼튼하게 만들어서 여러 상황들에 대응하도록 해야 한다.
	- *인터페이스, 정보 은닉, 자원 관리, 에러 처리*를 고려해야 한다.
- **인터페이스** :
	- *char csvgetline(FILE)* : CSV 형식 한 줄을 읽는다.
	- *char csvfiled(int n)*: 현재 줄의 n번째 필드를 리턴한다.
	- *int csvnfiled(void)*: 현재 줄의 필드 개수를 리턴한다.
- **정보 은닉** : 
	- *csvgetline*이 다음 줄을 읽어오면 그게 얼마나 크든 상관없이 *csvfield(n)* 이 현재 줄 n번째 필드의 바이트 크기만큼에 대한 포인터를 리턴한다. 
	- 그리고 *csvnfield*가 현재 줄의 필드 개수를 리턴한다. 
	- 더 긴 줄이나 더 많은 필드가 들어오면 메모리를 더 할당해야 한다. 그러나 이러한 세부 사항들은 csv 함수에 숨겨져 있어서 다른 프로그램에서는 알 수가 없다.
	- 만약 사용자가 *csvgetline*만 호출한다면 굳이 필드로 분리할 필요가 없다. 필드 분리가 적극적으로(줄을 읽자마자 바로), 또는 게으르게(필드나 필드 개수가 필요할 때만), 또는 엄청 게으르게(요청받은 필드만) 이루어지는지와 같은 세부 구현 사항도 사용자에게는 숨긴다.
- **자원관리** : 
	- 누가 공유 정보를 책임질지 결정해야 한다. 
		- *csvgetline*은 원본 데이터를 리턴할까 아니면 복사본을 만들까?
		- *csvgetline*의 리턴값을 원 입력에 대한 포인터로 결정했으므로, 그 원 입력은 다음 줄을 읽을 때 덮어씌워진다. 
		- 분리된 필드는 입력 줄의 복사본 내에 위치할 것이므로, *csvfield*는 그 복사본 안의 필드에 대한 포인터를 리턴한다. 
		- 위와 같은 장치를 해두었으므로, 사용자가 특정 줄이나 필드를 저장하거나 변경하려면 또 다른 복사본을 만들어야 한다.
		- 그리고 더이상 필요하지 않게 된 시점에 메모리를 해제하는 것도 사용자의 책임다.
	- 누가 입력파일을 열고 닫을까?
		- 입력 파일을 여는 곳이 어디든 열었으면 반드시 닫아야 한다. 
		- 우리는 *csvgetline*이 미리 열린 파일에 대한 *FILE 포인터*를 인자로 삼아 호출되고, 작업이 끝났을 때 *호출자*가 이 FILE 포인터를 닫는다고 가정하기로 했다. 
		- 공유 자원이나, 라이브러리와 그 호출자 사이의 경계를 넘나드는 자원을 관리하는 것은 어려운 일이며, 다양한 설계 상의 선택들을 고려하게 될 만한, 그 자체로는 그럴듯하면서도 서로 골치 아픈 이유들이 많다. *공유 책임에 대한 오해와 실수*는 버그를 만드는 흔한 *원인*인다.
- **에러 처리** :
	- 원칙적으로 라이브러리 루틴은 에러가 발생했을 때 그냥 죽어버리면 안된다.
	- 호출자가 적절한 동작을 취할 수 있도록 에러 상태를 리턴해야 한다. 
	- *에러 처리*는 이것 하나만으로도 따로 논해야 할 만큼 중요한 주제다. 
- **명세서** : 
	- 앞에서 내린 선택을 한군데 모아 *csvgetline*이 제공할 수 있는 서비스의 목록과 사용법을 설명한 *명세서*로 만들어야 한다. 
	- 대규모 프로젝트라면 명세서 작성은 구현보다 먼저 진행된다. 
	- 가장 좋은 접근 방식은 *명세서를 일찍 작성*한 다음, 구현하면서 깨달은 것들을 반영해 *계속 갱신*하는 것이다. 
	- 명세서를 *더 정확하고 더 신중하게* 쓸수록, 프로그램이 잘 돌아갈 가능성이 더 높아진다. 
	- 개인적으로 쓰는 프로그램이라 해도 어느 정도 상세한 명세서를 준비하면 유용하게 쓸 수 있다. 
	- 여러 대안을 고려할 수 있게 도와주고 선택한 결과를 기록해 놓을 수 있기 때문이다.
	  
``` ad-info
title: 명세서는 다음과 같이 **함수 원형**과 **동작방식**, **책임**, **가정한 사항들의 상세한 설명**을 포함하게 될 것이다.

- 필드는 콤마로 구분한다.
- 필드를 큰 따옴표로 둘러쌀 수도 있다.
- 따옴표로 둘러싼 필드는 콤마를 표현할 수 있지만 개행문자는 포함하지 않는다.
- 필드는 텅 빌 수 있고 ""로 표시한다. 빈 문자열도 빈 필드를 의미한다.
- 앞뒤의 공백은 유지된다.

- **char csvgetline(FILE f);**
	- 열린 입력 파일 f에서 한 줄을 읽어 오며, 이 때 입력줄은 \r, \n, \r\n, EOF로 끝난다고 가정한다.
	- 종결자를 제거하고 입력줄에 대한 포인터를 리턴하거나, EOF에 이른 경우 NULL을 리턴한다.
	- 입력줄은 임의의 길이가 될 수 있으며, 만약 메모리가 부족하면 NULL을 리턴한다.
	- 입력줄은 읽기전용 저장공간처럼 취급해야 한다. 입력 내용을 보존하거나 변경하려면 반드시 호출자가 복사본을 만들어야 한다.
- **char csvfield(int n);**
	- 필드 번호는 0에서 시작한다.
	- csvgetline이 읽은 마지막 줄에서 n번째 필드를 리턴한다.
		- n이 0보다 작거나 마지막 필드 번호를 넘어가면 NULL을 리턴한다.
	- 필드는 콤마로 구분한다.
	- 필드는 "..."로 둘러쌀 수 있다. 이런 따옴표는 제거된다.
	- ""..." 에서 ""는 "로 대체되며 콤마는 구분자가 아니다.
	- 따옴표로 둘러싸지 않든 필드에서 따옴표는 일반 문자처럼 취급한다.
	- 임의의 필드 길이와 갯수가 있을 수 있다.
		- 메모리가 부족하면 NULL을 리턴한다.
	- 필드는 읽기전용 저장공간처럼 취급해야 한다.
		- 필드 내용을 보존하거나 변경하려면 반드시 호출자가 복사본을 만들어야 한다.
	- csvgetline이 호출되기 전에 이 함수를 호출했을 때의 동작은 정의되지 않는다.
- **int csvfield(void);**
	- csvgetline이 읽은 마지막 줄에서 필드의 개수를 리턴한다.
	- csvgetline이 호출되기 전에 이 함수를 호출했을 때의 동작은 정의되지 않는다.
```

# 4.5 인터페이스 원칙

- 인터페이스는 서비스를 제공하는 코드와 그 서비스를 이용하는 코드 사이에의 정교한 경계선이 된다.
- 인터페이스는 구현 코드가 사용자를 위해 어떤 일을 해주는지, 또 함수나 데이터 멤버를 어떻게 사용할 수 있는지 정의한다.
- 우리가 만든 CSV 인터페이스는 세 가지 함수를 제공한다.
	- 입력을 한 줄 읽는 함수,
	- 필드 하나의 내용을 알려주는 함수, 
	- 필드 개수를 리턴하는 함수다. 
- 어떤 인터페이스가 널리 쓰이기 위해서는 그 목표에 잘 어울려야 한다. 
	- 단순하고
	- 범용적이고
	- 규칙적이고
	- 결과를 예상할 수 있고,
	- 튼튼하며 유연해야 한다.
	- **좋은 인터페이스는 원칙을 따른다.**

###### 원칙 1 : 구현의 세부 사항을 숨겨라

- 인터페이스 뒤에 존재하는 구현된 코드는 숨겨져야한다.
	- 그래야만 프로그램의 다른 부분에 영향을 주지 않고 변경할 수 있기 때문이다.
		- 이러한 원칙을 정보 은닉, 캡슐화, 추상화, 모듈화로 부른다.
	- 전역 변수 사용을 피해야 한다. 가능하면 필요한 모든 데이터는 함수 인자로 전달해서 쓰는 것이 좋다.
	- 이러한 원칙이 적용된 것이 *C++과 자바의 class*이다.

###### 원칙 2 : 서로 겹치지 않게 기본 항목들을 선택하라

- 인터페이스는 딱 필요한 만큼의 기능만 제공해야 한다. 
- 폭 넓은 인터페이스보다 압축적인 인터페이스를 더 선호해야 한다.

###### 원칙 3 : 사용자가 모르는 곳에서 일을 꾸미지 말라

- 라이브러리 함수는 비밀 파일이나 변수를 만들고 쓴다거나 전역 데이터를 변경해서는 안 된다.
- 또한 호출자가 전달한 데이터를 수정하는 일도 삼가야 한다.
- 단일 인터페이스를 쓸 때, 그 인터페이스 설계자나 구현자의 편의를 위해 또다른 인터페이스를 만들어야 하는 일이 있어서는 안된다.

###### 원칙 4 : 어디서나 같은 일은 같은 방식으로 처리하라

- 일관성과 규칙성은 중요하다.
- 비슷한 것들은 비슷한 수단으로 취해야 한다. 
- 외부에 대한 일관성, 즉 다른 것과 비슷하게 작동하는 일관성도 목표가 되어야 한다. 

# 4.7 중단, 재시도 실패?

- 앞 장에서는 에러를 처리할 때 *eprintf*나 *estrdup* 같은 함수를 써서 실행 종료 전에 메시지를 출력하게 했다. 

- **eprintf 함수** :
``` c++
#include <stdarg.h>
#include <string.h>
#include <errno.h>

/* eprintf: print error message and exit */
void eprintf(char *fmt, ...) {
    va_list args;
    fflush(stdout);

    if (progname() != NULL)
        fprintf(stderr, "%s: ", progname());

    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);

    if (fmt[0] != '\0' && fmt[strlen(fmt)-1] == ':')
        fprintf(stderr, " %s", strerror(errno));

    fprintf(stderr, "\n");
    exit(2); /* conventional value for failed execution */
}
```

- *#include* 지시문은 필요한 헤더 파일을 포함합니다.
- *eprintf* 함수는 가변 인자 목록을 사용하여 다양한 형식의 오류 메시지를 처리할 수 있습니다.
- *fflush(stdout)* 는 표준 출력 버퍼를 비웁니다.
- *progname()* 는 프로그램 이름을 반환하며, 오류 메시지에 프로그램 이름을 포함시키기 위해 사용됩니다.
- *va_start*와 *va_end*는 가변 인자 목록을 처리합니다.
- *vfprintf* 함수는 가변 인자 목록을 사용하여 오류 메시지를 표준 오류(*stderr*)로 출력합니다.
- 만약 오류 메시지의 마지막 문자가 콜론(`:`)이라면, *strerror(errno)* 를 사용하여 시스템 오류 메시지를 추가합니다.
- 마지막으로, *exit(2)* 는 실패를 나타내는 전통적인 값으로 프로그램을 종료합니다.

``` ad-tip
title: Q. 이 *eprintf 함수*가 하는 역할은 무엇이지?
제공해주신 `eprintf` 함수는 C 프로그래밍 언어에서 오류 처리를 위해 사용되는 함수입니다. 이 함수의 주된 역할은 오류 메시지를 출력하고 프로그램을 종료하는 것입니다. 함수의 구체적인 역할을 살펴보면 다음과 같습니다:

1. **오류 메시지 출력**:
   - 함수는 포맷 문자열(`fmt`)과 그에 해당하는 가변 인자들을 받아들여, 이를 표준 오류 출력 스트림(`stderr`)으로 출력합니다. 이는 `printf` 함수와 유사하지만, 오류 메시지를 표준 오류로 출력하는 점이 다릅니다.
   - `va_start`와 `va_end`는 가변 인자 목록을 처리하는 데 사용됩니다. `vfprintf` 함수는 이 가변 인자 목록과 함께 제공된 포맷 문자열에 따라 오류 메시지를 구성합니다.

2. **프로그램 이름 포함 (옵션)**:
   - `progname()` 함수는 프로그램의 이름을 반환합니다. 이 이름은 오류 메시지의 시작 부분에 추가될 수 있어, 오류가 발생한 프로그램을 식별하기 쉽게 해줍니다.

3. **시스템 오류 메시지 추가**:
   - 만약 포맷 문자열의 마지막 문자가 콜론(`:`)이라면, 이 함수는 `strerror(errno)`를 사용하여 시스템 오류 메시지를 추가합니다. `errno`는 시스템 수준의 마지막 오류 코드를 나타내며, `strerror` 함수는 이 오류 코드에 대응하는 텍스트 메시지를 제공합니다.

4. **프로그램 종료**:
   - 마지막으로, 함수는 `exit(2)`를 호출하여 프로그램을 종료합니다. 여기서 `2`는 전통적으로 실행 실패를 나타내는 종료 코드입니다.

이 함수는 오류 처리를 위한 표준적인 방법을 제공하며, 특히 시스템 수준의 오류가 발생했을 때 유용하게 사용됩니다. 프로그램이 예상치 못한 상황에 직면했을 때, 사용자에게 유용한 정보를 제공하고 안전하게 종료하기 위해 사용됩니다.
```

- **estrdup 함수** :
``` c++
/* estrdup : 문자열을 복사하고, 에러 발생 시 종료 */
char *estrdup(char *s) {
    char *t;
    
    t = (char *) malloc(strlen(s)+1);
    if (t == NULL)
	    eprintf("estrdub(\"%.20s\") failed:", s);
	 strcpy(t, s);
	 return t;
}
```

``` ad-tip
title: Q. 이 코드에서 *estrdup 함수*가 하는 역할을 알려줘
`estrdup` 함수는 C 언어에서 사용되는 사용자 정의 함수로, 주어진 문자열 `s`를 복사하여 새로운 메모리 공간에 저장하고, 그 새로운 메모리 주소를 반환하는 역할을 합니다. 함수의 주요 작업은 다음과 같습니다:

1. **메모리 할당**:
   - `malloc` 함수를 이용하여 원본 문자열 `s`의 길이(`strlen(s)`)에 1을 더한 만큼의 메모리를 동적으로 할당합니다. 여기서 1을 더하는 이유는 문자열 끝에 널 종료 문자(`\0`)를 위한 공간을 확보하기 위함입니다.

2. **메모리 할당 검사**:
   - 할당된 메모리의 주소를 `t`에 저장합니다. 만약 `malloc` 함수가 메모리 할당에 실패하면, `NULL`을 반환합니다.
   - `t`가 `NULL`인 경우, 즉 메모리 할당에 실패한 경우, `eprintf` 함수를 호출하여 오류 메시지를 출력하고 프로그램을 종료합니다. 이때 `"estrdup(\"%.20s\") failed:"` 형식의 문자열을 오류 메시지로 사용하여, 어떤 문자열의 복사가 실패했는지를 나타냅니다.

3. **문자열 복사**:
   - `strcpy` 함수를 사용하여 원본 문자열 `s`를 새로 할당된 메모리 공간 `t`로 복사합니다. 이 과정에서 원본 문자열의 모든 문자가 새 메모리에 복사되며, 널 종료 문자도 포함됩니다.

4. **복사된 메모리 주소 반환**:
   - 문자열 복사가 완료된 후, 새로운 메모리 주소를 가리키는 포인터 `t`를 반환합니다. 호출자는 이 주소를 사용하여 복사된 문자열에 접근할 수 있습니다.

`estrdup` 함수는 기본 C 라이브러리에는 포함되어 있지 않은, 하지만 문자열을 다룰 때 자주 필요한 기능을 제공하는 함수입니다. 메모리 관리와 오류 처리를 함께 고려하여 안전하게 문자열을 복사하는 방법을 제시합니다.
```

- **emalloc 함수** :
``` c++
/* emalloc : 메모리를 할당하고, 에러 발생 시 종료 */
void *emalloc(size_t n) {
    void *p;
    
    p = malloc(n);
    if (p == NULL)
	    eprintf("malloc of %u bytes failed:", n);
	 return p;
}
```

``` ad-tip
title: Q. 이 코드에서 *emalloc 함수*가 하는 역할을 알려줘
`emalloc` 함수는 C 프로그래밍 언어에서 사용되는 사용자 정의 함수로, 지정된 크기의 메모리를 동적으로 할당하고 그 주소를 반환하는 역할을 합니다. 만약 메모리 할당에 실패할 경우, 오류 메시지를 출력하고 프로그램을 종료합니다. 함수의 주요 작업은 다음과 같습니다:

1. **메모리 할당**:
   - `malloc` 함수를 사용하여 인자로 받은 크기 `n`만큼의 메모리를 동적으로 할당합니다.

2. **메모리 할당 검사**:
   - 할당된 메모리의 주소를 `p`에 저장합니다. 만약 `malloc` 함수가 메모리 할당에 실패하면, `NULL`을 반환합니다.
   - `p`가 `NULL`인 경우, 즉 메모리 할당에 실패한 경우, `eprintf` 함수를 호출하여 오류 메시지를 출력하고 프로그램을 종료합니다. 이때 `"malloc of %u bytes failed:"` 형식의 문자열을 오류 메시지로 사용하여, 몇 바이트의 메모리 할당이 실패했는지를 나타냅니다.

3. **할당된 메모리 주소 반환**:
   - 메모리 할당이 성공하면, 할당된 메모리 주소를 가리키는 포인터 `p`를 반환합니다. 호출자는 이 주소를 사용하여 할당된 메모리에 접근할 수 있습니다.

`emalloc` 함수는 기본 C 라이브러리의 `malloc` 함수를 확장하여, 메모리 할당 실패 시 프로그램을 안전하게 종료하도록 하는 추가적인 오류 처리 기능을 제공합니다. 이는 안정성을 높이고, 메모리 관리 중 발생할 수 있는 오류를 효과적으로 처리하는 데 도움이 됩니다.
```

- **헤더 파일 eprintf.h** :
``` c++
/* eprintf.h: error wrapper functions */
extern void eprintf(char *, ...);
extern void weprintf(char *, ...);
extern char *estrdup(char *);
extern void *emalloc(size_t);
extern void *erealloc(void *, size_t);
extern char *progname(void);
extern void setprogname(char *);
```

``` ad-tip
title: Q. 이 헤더 파일 *eprintf.h*는 분리해서 사용하나?
제공된 코드에서 `eprintf.h` 헤더 파일은 eprintf 관련 함수들의 선언을 담고 있습니다. 이와 같은 함수들의 선언을 별도의 헤더 파일에 넣는 것은 좋은 프로그래밍 관행입니다. 이런 방식으로 헤더 파일을 분리하는 것은 다음과 같은 이유로 권장됩니다:

1. **모듈성**: 헤더 파일을 사용함으로써 코드의 모듈성을 높일 수 있습니다. 각 헤더 파일은 특정 기능이나 관련 함수들의 집합을 정의하므로, 개발자는 필요한 기능만을 포함시킬 수 있습니다.

2. **재사용성**: 분리된 헤더 파일은 다른 프로젝트나 소스 파일에서 쉽게 재사용될 수 있습니다. 이렇게 하면 코드 중복을 피하고 일관성을 유지할 수 있습니다.

3. **유지보수성**: 소스 코드와 헤더 파일을 분리함으로써, 코드의 유지보수가 용이해집니다. 예를 들어, 함수 선언이 변경되어야 할 경우, 헤더 파일만 수정하면 되며, 이 변경사항이 해당 헤더 파일을 포함하는 모든 소스 파일에 자동으로 적용됩니다.

4. **명확한 인터페이스 제공**: 헤더 파일은 해당 라이브러리나 모듈의 인터페이스를 정의합니다. 이를 통해 개발자는 구현 세부 사항에 집중하기보다는 함수의 인터페이스에 더 집중할 수 있습니다.

5. **컴파일 시간 최적화**: 헤더 파일을 사용하면, 컴파일러는 필요한 부분만을 컴파일할 수 있어 컴파일 시간을 줄일 수 있습니다. 또한, 변경이 필요 없는 부분은 재컴파일할 필요가 없어지므로, 전체적인 빌드 프로세스가 효율적으로 진행됩니다.

이러한 이유로, `eprintf.h`와 같은 헤더 파일은 `eprintf`, `estrdup`, `emalloc` 등의 함수 선언을 분리하여 관리하는 것이 좋습니다. 이렇게 하면 다른 소스 파일에서 이 함수들을 사용할 때, 단순히 `eprintf.h`를 포함시키기만 하면 됩니다. 이는 코드의 가독성, 재사용성 및 유지보수성을 크게 향상시킵니다.
```


- **프로그램 이름 관리와 'main' 함수** :
``` c++
static char *name = NULL; /* program name for messages */

/* setprogname: set stored name of program */
void setprogname(char *str){
	name = estrdup(str);
}

/* progname: return stored name of program */
char *progname(void){
	return name;
}

int main{int argc, char *argv[]}{
	setprogram("markov")
	...
	f = fopen(argv[i], "r");
	if (f == NULL) eprintf("can't open %s:", argv[i]);
	...
}
```

``` ad-tip
title: Q. 위 코드가 하는 역할은 무엇일까?
1. **프로그램 이름 관리**:
    - `static char *name`은 프로그램의 이름을 저장하는 데 사용되는 전역 변수입니다.
    - `setprogname` 함수는 프로그램의 이름을 설정하고, `estrdup` 함수를 사용하여 이 이름을 동적으로 복사합니다.
    - `progname` 함수는 설정된 프로그램 이름을 반환합니다.
      
      
2. **`main` 함수**:
    - 프로그램의 주 진입점인 `main` 함수는 `setprogname`을 호출하여 프로그램 이름을 설정합니다. 여기서 `"markov"`라는 문자열이 프로그램 이름으로 사용되고 있습니다.
    - 프로그램은 커맨드 라인 인자로 제공된 파일들을 열려고 시도합니다. `fopen` 함수를 사용하여 각 파일을 열고, 파일이 성공적으로 열리지 않으면 `eprintf` 함수를 호출하여 오류 메시지를 출력하고 프로그램을 종료합니다.

이 코드의 핵심은 `eprintf.h`에 정의된 함수들을 사용하여 오류 메시지를 출력하고, 필요한 메모리 관리 작업을 수행하는 것입니다. 특히, `eprintf` 함수는 오류 발생 시 프로그램을 즉시 종료하며, `estrdup` 함수는 문자열을 안전하게 복사하는 데 사용됩니다. 이렇게 별도의 헤더 파일에 정의된 함수들을 사용함으로써, 코드의 재사용성과 모듈성을 높이고, 오류 처리를 효과적으로 관리할 수 있습니다.
```

###### 에러처리 원칙 1 : 에러는 저수준에서 잡고, 고수준에서 처리하라

- 일반적으로 에러는 가능한 낮은 수준에서 잡아야 하고, 높은 수준에서 처리해야 한다.
- 대부분의 경우 피호출자가 아닌 호출자가 에러를 어떻게 처리할지 결정한다. 
	- 여기에서 라이브러리 루틴이 점잖게 조용히 실패하는 방식을 취하면 도움이 된다.
	- *존재하지 않는 필드가 나오면 중단하는 대신 NULL을 리턴하는 것이다.*
- 어떤 값을 리턴해야 좋을지가 항상 분명한 것은 않기 때문에 리턴 값의 케이스들을 미리 염두해 두어야 한다(?)
	- 잘못된 데이터가 들어왔을 경우에는 EOF와 같이 문자 타입이 아닌 값을 리턴할 수 있다.
	- 수학 관련 함수는 모든 부동 소수점 값을 리턴할 수 있다. 
	- 펄이나 Tcl 같은 일부 언어는 쉽고 빠르게 두 개 이상의 값들을 투플이라는 그룹으로 묶어주는 기능을 제공하기 때문에 함수값이나 에러 상태를 쉽게 하나로 묶어서 리턴할 수 있다.
- 가능하다면 파일 끝이나 여러 에러 상태등 다양한 예외 값들을 하나로 뭉쳐서 표현하기보다는 따로 구분하는 것이 좋다. 

###### 에러처리 원칙 2 : 예외적 상황에서만 예외 처리를 하라

- 예외는 쉽게 남용되곤 한다.
- 예외는 제어 흐름을 건드리기 때문에 버그가 발생하기 쉽게 구조를 돌돌 꼬아놓을 수도 있다.
	- 예를 들어 파일을 열 때 실패하는 것은 *예외적인 일이 아니다*.
	- 그러나 파일 시스템이 꽉 차거나, 부동소수점 연산 관련 에러가 발생하는 경우는 *정말 예외적인 일*이다.
- 에러가 발생했을 때 자원은 어떻게 반납해야 할까?
	- 정보를 가능한한 깨끗하고 해가 되지 않는 상태로 남겨두자.
	- 사용하지 않는 메모리는 해제해야 한다.
	- 라이브러리 밖에서도 변수에 아직 접근할 수 있다면 루틴을 끝내기 전에 적당한 값을 설정해야 한다.
	- 일반적으로 *에러가 발생한 뒤에도 계속 라이브러리를 사용할 수 있게 만드는 것을 목표*로 하자