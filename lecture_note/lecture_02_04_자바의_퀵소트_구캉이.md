# 2장 알고리즘과 데이터 구조

"결국 어떤 문제가 생겼을 때 올바른 해결책을 제시하는 것은 현장에서의 기법과 도구에 대한 숙련도뿐이며, 전문가다운 결과를 지속적으로 뽑아내는 것은 일정 수준 이상의 경험 뿐이다."

- 모든 프로그램은 알고리즘과 데이터 구조에 의지하지만, 완전히 새로운 알고리즘이나 데이터 구조를 발명해서 써야 하는 프로그램은 아주 드물다. 
- 내부에서 쓰는 데이터 구조는 대부분 배열, 리스트, 트리, 해시 테이블이다. 
- 따라서 대다수의 프로그래머들이 해야 할 일은 *어떤 알고리즘과 데이터 구조를 쓸 수 있을지 파악하고, 여러 대안 중 하나를 선택하는 방법을 이해하는 것*이다.

### 2.1 검색

- 정적 테이블 형태의 데이터를 저장하는 데는 배열을 따라갈 만한 것이 없다. 
- 배열은 컴파일 시점에 초기화되기 때문에 만들기 쉽고 비용도 적게 든다. 

``` Java
/* 같은 단어를 너무 자주 반복해서 쓴 좋지 않은 글에서
그런 단어를 찾아내기 위한 프로그램이라면 다음과 같은 코드가 들어갈 수 있을 것이다.*/

char *flab[] = {
	"actually",
	"just",
	"quite",
	"really",
	NULL
};
```

- 검색 루틴은 위의 배열에 원소가 몇 개나 들어 있는지 알아야 한다. 
- 여기서는 배열의 끝에 NULL을 넣어 표시하는 방법을 사용했다.

``` Java
/* lookup : 배열에 들어 있는 단어를 순차 검색*/
int lookup(char *word, char *arry[])
{
	int i;
	
	for (i=0; array[i] !=NULL; i++)
		if (strcmp(word, array[i]) == 0)
			return i;
	return -1;
}
```

- 이 검색 알고리즘은 '순차 검색(squential search)'이라고 하는데, 그 이유는 원하는 원소가 나올 때까지 모든 원소를 차례대로(순차적으로) 살펴보기 때문이다.
	- 순차 검색은 데이터 개수가 적을 경우 속도가 빠르다.
	- 그러나, 찾을 데이터의 전체 크기와 작업량이 정비례한다.
		- 실행 시간과 데이터 크기가 일차 함수 관계이기 때문에 이것은 선형 관계(linear relation-ship)라고 부르며, 이런식의 검색을 '선형 검색'이라고 부른다.

``` JAVA
/* 아래는 HTML을 파싱하는 프로그램에서 뽑아낸, 좀 더 현실적인 크기의 배열을 사용하는 코드다. 여기에서 사용하는 배열의 크기는 100을 넘으며, 각각 HTML 글자에 대한 이름을 갖고 있다. */

~~코드
```

- 대규모 배열의 경우 '**이진 검색(binary search)**'을 사용하는 것이 더 낫다.
- 이진 검색 알고리즘은 우리가 사전에서 단어를 찾아보는 방법을 규칙적으로 만들어 놓은 것이다.
	- 먼저, 배열의 가운데에 있는 원소를 살펴본다.
		- *그 원소의 값이 우리가 찾고 있는 값보다 크다면* 앞쪽 절반을 검색 범위로 쓰고,
		- *그렇지 않다면* 뒤쪽 절반이 검색 범위가 된다.
		- 원하는 원소를 찾거나 그 원소가 없다고 판단될 때까지 이 과정을 *반복*한다.
		- 이진 검색은 매 단계마다 *데이터 절반을 검색 대상에서 제외*한다.
			- 따라서 반복 횟수는 원소가 하나만 남을 때까지 n을 2로 나눌 수 있는 횟수에 비례한다.
			- 소수 이하를 무시한다면, 이것은 log2n이다.	
- **이진 검색의 조건**
	1. 이진 검색을 하려면 먼저 검색할 배열이 반드시 정렬되어 있어야 한다.
	2. 또한 테이블의 크기도 알고 있어야 한다.
- **선형 검색 vs 이진검색**
	- 만약 검색할 대상이 1,000개라면, 
		- 선형 검색은 천 번 검색을 해야 하지만,
		- 이진 검색은 열 번이면 충분하다.
	- 원소의 수가 백만개라면,
		- 선형 검색은 백만 번이고,
		- 이진 검색은 스무 번이다.
	- 원소 수가 많아질 수록 이진 검색의 장점이 두드러진다.

### 2.2 정렬

- *이진 검색*은 원소가 정렬되어 있을 때만 쓸 수 있다.
	- 만약 어떤 데이터 집합을 여러번 검색할 예정이라면, 처음에 한 번 정렬해 놓은 다음 이진 검색을 사용하는 것이 좋다.
	- 데이터 집합이 미리 정해져 있다면, 프로그램을 작성할 때 정렬해 두고 컴파일 시점에 초기화 할 수 있다. 
	- 그렇지 않다면 프로그램 실행 중에 정렬해야 한다.
- 1960년에 C. A. R. 호어가 고안해낸 '**퀵소트(quicksort)**'는 어떤 상황에서 무난한 *최고의 정렬 알고리즘* 중 하나다.
	- **퀵소트**는 불필요한 계산을 피하는 방법을 제시하는 좋은 예이기도 하다. 
	- 이 알고리즘은 배열의 모든 원소를 *기준값보다 작거나 큰 부분으로 나누는 방식으로 작동*한다.
		- **퀵소트 작동법**
			- 배열의 한 원소를 선택한다. (이 원소가 '*기준(pivot)*'이다.)
			- 다른 원소들을 두 집단으로 분할한다.
				- 기준보다 작은 값을 갖는 집단
				- 기준보다 크거나 같은 값을 갖는 집단
			- 각 집단을 이런 식으로 *반복*해서 *정렬*한다.
		- 이 절차가 완료되면 배열은 **정렬된 상태**가 된다. 
			- **퀵소트가 빠른 이유**는 일단 *어느 원소가 기준 원소 값보다 작다고 판명*되면, 그 원소를 *기준 값보다 큰 원소들과 비교하지 않아*도 되기 때문이다. 
			- 마찬가지로, 큰 원소도 작은 원소들과 비교할 필요가 없다. 
	- **퀵소트**는 실용적이며 효율적이다.

``` JAVA
/* quicksort: sort v[O]. .v[n-11 into increasing order */

void quicksort(int v[], int n)
{
	int i, last;
	if (n <= 1) /* nothing to do */
		return ;
	swap(v, 0, rand() % n); /* move pivot elem to v[O] */
	last = 0;
	for (i = 1; i < n; i++) /* partition */
		if (v[i] < v[O])
			swap(v, ++last, i);
		swap(v, 0, last); /* restore pivot */
		quicksort(v, last); /* recursively sort */
		quicksort(v+last+l, n-last-1); /* each part */ 
}
```

- 위 **quicksort** 함수는 *정수(integer) 배열*을 정렬한다.
	- 두 원소의 위치를 바꾸는 swap 작업은 quicksort 함수 안에서 세 번이나 등장하므로, 따로 함수로 만드는 편이 좋다.

``` JAVA
/* swap: interchange v[il and v[j] */

void swap(int v[], int i, int j)
{
	int temp;
	
	temp = v[i];
	v[i] = v[j];
	v[j] = temp;
}
```

 **분할작업**
1. 임의의 원소를 *기준(pivot)* 으로 선택하고,
2. 그것의 위치를 임시로 배열의 *첫번째 원소와 바꿔치기*한 다음
3. 나머지 원소들을 차례차례 검사하면서 *기준*보다 *작은 것들*은 배열의 *앞쪽*에(last의 위치에) 놓고
4. 기준보다 큰 것들은 배열의 뒷쪽에(i의 위치에) 모은다.
5. 분할 절차가 막 시작될 때, 즉 기준값과 원소를 바꾼 직후에는 last = 0이며 원소 i=1부터 n-1까지는 아직 검사되지 않은 상태다.

![[Pasted image 20230926210258.png]]

6. *for 반복문*이 시작될 때는, 원소 1번부터 last번까지는 확실히 기준보다 값이 작고,
7. *원소 last+1번부터 i-1번까지*는 기준보다 값이 크거나 같으며,
8. *원소 i번부터 n-1번까지*는 아직 검사되지 않은 상태다. 
9. 이 알고리즘은 v[i]가 v[0]보다 크거나 같아질때까지는 v[i]를 계속 그 자신과 바꿀 수도 있다.

![[Pasted image 20230926210746.png]]

10. 모든 원소를 두 집단으로 분할한 후에는
11. *0번 원소*와 *last번 원소*의 위치를 바꿔 기준을 최종 위치에 놓는다.
12. 이렇게 해야 **올바른 정렬 상태**를 유지할 수 있다. 
13. 이제 배열은 다음과 같은 모습일 것이다.

![[Pasted image 20230926210933.png]]

14. 그런 다음 이것과 동일한 절차를 왼쪽 하위 배열과 오른쪽 하위 배열에 각각 적용하면 된다.
15. 이 일이 끝날 때에는 **전체 배열이 정렬된 상태**가 될 것이다.

#### 퀵소트는 얼마나 빠를까?

- *첫 번째 분할 단계* : n개의 원소가 각각 대략 n/2개의 원소를 가지는 두 부분으로 나뉜다.
- *두 번째 분할 단계* : 두 n/2개 부분이 각각 n/2개의 원소를 가지는 두 부분으로 나뉘어 n/4개 부분이 네 개가 된다.
- *세 번째 분할 단계* : 대략 n/4개의 원소를 가지는 네 부분이 또 다시 각각 나뉘어 대략 n/8개의 원소를 가지는 여덟 부분으로 된다.
- 이런 식으로 계속 반복 : n+2 x n/2 + 4 x n/4 + 8 x n/8 ... 이 식의 항 개수는 log2n개이며, 즉 nlog2n에 비례한다.
- 로그에서 밑이 2면 보통 생략하므로, 퀵소트의 작업시간은 nlogn에 비례한다고 말할 수 있다.

#### 퀵소트의 약점

- 만약 기준(pivot)을 선택할 때마다 나머지 원소 값들이 크기가 같은 두 집단으로 깔끔하게 나뉜다면, 정확히 우리가 예상한대로 정렬될 것이다.
- 그러나 원소들이 균등하게 분할되지 않는 경우가 너무 자주 일어난다면 실행시간이 n2에 더 가까워질지도 모른다.
- 그래서 소트 알고리즘은 좀 더 신경써서 정교하게 만든다면 이런 상황이 거의 발생하지 않을 것이다.

---
### 2.4 자바의 퀵소트

- 자바의 최근 버전에서는 Comparable 인터페이스를 구현하는 클래스를 대상으로 작동하는 sort 함수가 제공된다.
- 따라서 이제는 라이브러리를 이용해서 정렬을 할 수 있게 되었다.
- 하지만 *자바에서 퀵소트를 구현하면서 배울 수 있는 기법*들이 *다른 상황에서 유용하게 쓰일 수 있으므로*,
- 우리는 여기에서 자바에서 **퀵소트를 구현하기 위한 세부사항들**을 살펴볼 것이다.

#### 정렬할 타입에 의존하지 않는 정렬 함수 만들어보기

- C나 C++과 자바의 큰 차이점은 자바는 *비교 함수*를 *다른 함수에 전달*하는 일이 *불가능*하다는 것이다. (자바에는 *함수 포인터*가 없기 때문이다.)
- 그 대신 우리는 *두 오브젝트를 비교하는 함수 하나*만 들어 있는 *인터페이스*를 만들 것이다.
- 그리고 정렬할 데이터 타입마다 각각 이런 인터페이스를 구현하는 *멤버 함수를 포함한 클래스*를 만든다.
- 우리가 이 *클래스*의 인스턴스를 정렬 함수에게 넘겨주면, 정렬 함수는 그 클래스에 들어있는 비교 함수를 사용해서 원소를 비교한다.

##### 우리가 만들 정렬 함수의 요소

1. 두 오브젝트를 *비교*하는 *함수* 하나만 들어있는 *인터페이스*
2. 정렬할 데이터 타입마다 1번의 인터페이스를 구현하는 *멤버 함수를 포함한 클래스*

##### 우리가 만들 정렬 함수의 작동방식

2번의 클래스의 인스턴스를 **정렬 함수**에게 넘겨주면, 클래스에 들어있는 *비교 함수*를 사용해서 원소를 비교한다.

###### 1. 인터페이스

``` JAVA
interface Cmp {
	int cmp(Object x, Object y);
}
```

###### 2. 비교 함수

``` JAVA
// Icmp : 정수 비교
class Icmp implements Cmp {
	public int cmp(Object o1, Object o2)
	{
		int i1 = ((Integer) o1). intValue();
		int i2 = ((Integer) o2). i ntValue();
		if (il < i2)
			return -1;
		else if (il == i2)
			return 0;
		else
			return 1;
	}
}
```

###### 3. 클래스 (String 두 개를 비교하는 함수를 정의)

``` JAVA
// Scmp: String 비교
class Scmp implements Cmp {
	public int cmp(Object o1. Object o2)
	{
		String sl = (String) o1;
		String s2 = (String) o2;
		return sl.compareTo(s2);
	}
}
```

- 이 매커니즘으로는 오브젝트에서 파생된 타입만 정렬할 수 있으며,
- *int나 double 같은 기본 타입*은 이 방법으로 정렬하지 못한다.
- 그렇기 때문에, int가 아니라 *integer를 정렬하는 것*이다.

---
##### C의 퀵소트 함수를 자바용으로 변환해서 그 함수가 인자로 넘겨받은 Cmp 객체의 비교 함수를 호출하게 만들기

- 이 함수에서는 *left*와 *right*라는 인덱스 변수를 사용한다. (자바에서는 배열을 포인터로 사용할 수 없기 때문)

``` JAVA
// Quicksort.sort: v[left] . .v[right]를 퀵소트로 정렬
static void sort(Object[] v, int left, int right, Cmp cmp)
{
	int i, last;

	if (left >= right) // 할일 없음, 종료
		return;
	swap(v, left, rand(1eft. right)); // 기준 원소를
	last = left;                      // v[left]로 이동
	for (i = left+l; i <= right; i++) // 분할하기
		if (cmp.cmp(v[i], left]) < 0)
			swap(v, ++last, i);
	swap(v, left, last);              // 기준 복원
	sort(v, left, last-1, cmp);       // 각 부분을 재귀적으로
	sort(v, last+l, right, cmp) ;     // 정렬
}
```

- *Quicksort.sort*는 두 객체를 비교하기 위해 cmp를 사용하고 전과 마찬가지로 객체 위치를 교환하기 위해 swap을 부른다.

``` JAVA
// Quicksort.swap: v[i]와 v[j]의 위치를 바꿈
static void swap(Object[] v, int i, int j)
{
	Object temp;
	
	temp = v[i];
	v[i] = v[j];
	v[j] = temp;
}
```

- *난수 생성*은 left와 right 자체의 값을 포함한 두 값 사이의 범위에서 *임의의 정수를 하나 생성하는 함수*를 이용한다.

``` JAVA
static Random rgen = new Random();

// Quicksort.rand: [left, right] 범위에서 임의의 정수를 리턴
static int rand(int left, int right)
{
	return left + Math.abs(rgen. nextInt())%(right-left+1);
}
```

- 위에서 *Math.abs*를 이용해서 절대 값을 구하는데, 그 이유는 자바의 난수 생성기가 양수 뿐 아니라 음수도 만들어 내기 때문이다.
	- 하지만 *Math.abs*도 특수한 경우(인자가 그 인자 타입의 최소값과 동일한 경우)에는 마이너스 값이 나올 수 있으므로 해당 리턴 문을 다음과 같이 바꾸도록 권한다.
	- retuen left + rgen.nextInt(right-left+1);
- sort, swap, rand 함수와 난수 발생기 오브젝트 rgen은 **Quicksort 클래스의 멤버**다.

- 마지막으로, String 배열을 정렬하기 위해 **Quicksort.sort**를 쓰려면 다음과 같이 하면 된다.

``` JAVA
String[] sarr = new String[n];
// sarr에 n개의 원소를 채움
Quicksort.sort(sarr, 0, sarr.length-1, new Scmp());
```
 
- 문자열을 비교하기 위해 Scmp 오브젝트를 만들어 **sort 함수**를 호출한다.