
# 8장 호환성


``` ad-quote
마지막으로, 표준화(standardization)는 관례(convention)와 마찬가지로 강력한 규칙의 표현이 될 수 있다.
하지만 관례와 달리 현대 아키텍처에서 기술이 낳은 영양가 있는 산물로 받아들여져 왔다.
비록 그 잠재적인 독재력과 무자비함을 두려워하는 사람도 많았지만 말이다.
[로버트 벤츄리]
```

- **호환성(portability) 이란?**
	- 특정 환경에서 잘 돌아가는 것
	- 다른 환경에서도 잘 돌아가는 것
	- *즉, 어떤 환경에서도 잘 돌아가는 것*

- **호환성에 신경써야 하는 이유**
	- 첫째, '성공적인' 프로그램은 예상하지 못한 장소에 예상하지 못한 방식으로 실행된다.
	- 둘째, 환경은 변하기 마련이다.
	- 셋째, 호환 가능한 프로그램이 더 좋은 프로그램이다.

- **호환성의 세부 요소**
	- 다양한 표준과 인터페이스, 그 프로그램이 돌아가야 할 환경의 여러 교집합에서 다 잘 돌아가는 소프트웨어를 작성하기 위해 노력하라.
	- 모든 호환성 문제를 특수 코드를 추가하는 방법으로 해결하지 말고, 대신 그 소프트웨어가 새로운 제약 하에서 작동할 수 있게 전체적으로 조정해야 한다.
	- 어쩔 수 없는 비호환성 코드를 제한하고 제어하기 위하여 추상화와 캡슐화 기법을 이용하라.
	- 코드를 제약사항들의 교집합 하에 유지하고 시스템 의존성을 제한하면, 그 코드는 더 의미가 분명해지고 다른 환경으로 이식할 때도 더 범용으로 사용할 수 있을 것이다.

# 8.7 호환성과 업그레이드

``` ad-info
title: 가장 괴로운 호환성 문제의 원천 중 하나가 바로 생명주기 동안 계속 변경되는 시스템 소프트웨어다.
이런 변경은 그 시스템의 어떤 인터페이스에도 일어날 수 있기 때문에 기존 프로그램 간에 없었어도 될 비호환성이 발생한다.
```

###### (기능) 명세를 바꾼다면 이름도 바꾸라

*예시 1) Unix 시스템의 echo 명령어의 속성 변경*

1. **echo의 초기 설계 버전** : 인자를 그냥 *메아리(echo)처럼* 돌려주는 것
``` java
% echo hello, world
hello, world
%
```

2. **echo가 많은 스크립트의 핵심이 되면서 형식을 내놓는 게 중요해짐** : printf처럼 *인자를 '해석'하도록* 변경됨
``` java
% echo 'hello\nworld'
hello
world
%
```
 - *문제 발생* : 말 그대로 *메아리만 수행하던 echo 명령어에 의존하는 셸 스크립트*에서 호환성 문제가 생김 - **의도하지 않은 호환성 문제가 발생함**
	 - **% echo $PATH** : 이러한 명령은 이제 어떤 echo를 쓰느냐에 따라 동작 방식이 달라짐
		 - *DOS*나 *windows*에서처럼 변수에 역슬레시(\)가 들어있기라도 하면 아마 *echo가 해석*하게 될 것이다.
			 - 이 차이는 str에 % 기호가 들어가 있을 때 printf(str)과 printf('%s', str)의 출력 차이와도 비슷하다(?)

``` java 
예시 1: `printf(str)`

- 이 경우 `printf`는 `str` 변수의 내용을 직접 출력합니다.
	- 만약 `str` 내에 `%` 기호가 포함되어 있고, 그 뒤에 형식 지정자에 해당할 수 있는 문자가 온다면,
	- `printf`는 그 부분을 형식 지정자로 해석하려고 시도할 것입니다.
	- 이 때문에 예상치 못한 출력이나 오류가 발생할 수 있습니다.
		- 예를 들어, `str`의 값이 `"Discount is 20%"`라면 문제가 없지만,
		- `str`의 값이 `"Win rate: %d%%"` (여기서 `%d`는 정수를 출력하기 위한 형식 지정자)이고
		- 이 문자열을 그대로 `printf(str)`에 전달하면,
		- `printf`는 `%d`를 정수 값을 출력해야 하는 형식 지정자로 해석하려고 시도할 것이며,
		- 이로 인해 오류가 발생할 수 있습니다.

예시 2: `printf("%s", str)`

- 이 경우 `printf`에 첫 번째 인자로 전달된 `"%s"`는 `printf`에게 `str`의 내용을 문자열로서 그대로 출력하라고 지시합니다.
	- 이 방식에서는 `str` 내의 `%` 기호가 형식 지정자로 해석되지 않고,
	- 문자열의 일부로 취급되어 그대로 출력됩니다.
	- 따라서, `str`의 값이 `"Win rate: %d%%"`일 때 `printf("%s", str)`를 사용하면,
	- 출력 결과는 `Win rate: %d%%`로 예상대로 나타날 것입니다.
	- 이는 `printf`가 두 번째 인자인 `str`을 형식 지정자 없이 순수한 문자열로 해석하기 때문입니다.

```

 - **해결 방법** : 만약, echo의 새 버전에 별도로 이름을 줬다면 훨씬 상황이 편해졌을 것이다.

---

*예시 2) Unix 명령어 sum (sum은 체크섬을 출력한다.)*

1. 정보 전송이 제대로 됐는지 검증하기 위해 사용한 **sum**의 예시
``` java
% sum file
52313 2 file 
%
% 파일을 다른 시스템에 복사한다.
% 
% telnet othermachine
% sum file
52313 2 file
$
```
 - *출력 결과* : 전송 뒤에도 체크섬 값은 똑같기 때문에 이전 파일과 복사한 새 파일이 동일하다고 믿을 수 있다.

2. **sum**의 체크섬 알고리즘이 개선된 방식
``` java
% sum file
52313 2 file // `sum file` 명령어는 `file`이라는 이름의 파일에 대한 체크섬과 블록 수를 계산하여 출력합니다. 여기서 `52313`은 체크섬 값이고, `2`는 파일 크기에 따른 블록 수입니다. 이는 파일의 무결성을 검증하기 위한 초기 참조 값으로 사용됩니다.
% 
% 다른 시스템 2에 파일을 복사한다.
% 다른 시스템 3에 파일을 복사한다. // 이 부분은 사용자가 파일을 다른 시스템(여기서는 시스템 2와 시스템 3)으로 복사하는 과정을 설명합니다. 실제 명령어는 제시되지 않았지만, `scp`, `rsync` 등의 명령어를 사용할 수 있습니다.
% telnet machine2 // 사용자가 `telnet` 명령어를 사용하여 시스템 2에 원격 접속합니다. `telnet`은 원격 시스템에 로그인하기 위한 프로토콜이며, 여기서 `machine2`는 시스템 2의 주소나 호스트명을 의미합니다.
$
$ sum file
eaa0d468 713 file // 시스템 2에서 `sum file` 명령어를 실행하여 파일의 체크섬과 블록 수를 다시 계산합니다. 여기서 나온 체크섬 값 `eaa0d468`과 블록 수 `713`은 처음 계산된 값과 다릅니다. 이는 체크섬 알고리즘이나 파일 내용이 변경되었음을 나타낼 수 있습니다.
$ telnet machine3 // 이제 사용자가 `telnet`을 사용하여 시스템 3에 접속합니다.
> 
> sum file
62992 1 file // 시스템 3에서 `sum file` 명령어를 실행하여 파일의 체크섬과 블록 수를 계산합니다. 여기서 나온 체크섬 값 `62992`과 블록 수 `1` 역시 처음과는 다릅니다. 이는 시스템 2에서와 마찬가지로 체크섬 알고리즘이나 파일이 변경되었을 가능성을 시사합니다.
> 
```
- *출력 결과* : 파일에 문제가 생겼을까, 아니면 다른 버전의 sum을 쓴 것 뿐일까? *둘 다 일 수도 있다.*
  
- *문제 발생* : chat 선생 도움
	- 예시 2에서 제시된 **sum** 명령어의 사용 사례를 보면, 체크섬 알고리즘이 개선된 방식에서 문제가 있음을 암시합니다. 
	- 체크섬 값이 다른 시스템간에 다르게 나타나는 이유는 여러 가지가 있을 수 있으나,
	- 주로 *다음과 같은 문제들*을 고려할 수 있습니다 :
		- **다른 체크섬 알고리즘 사용**: 다른 시스템에서는 `sum` 명령어의 다른 버전이나 다른 체크섬 계산 알고리즘을 사용할 수 있습니다. 예를 들어, UNIX 시스템 간에는 `sum` 명령어의 구현이 약간씩 다를 수 있으며, 이는 출력된 체크섬 값에 영향을 줄 수 있습니다.
		- **파일 전송 중의 데이터 손상**: 파일이 다른 시스템으로 복사되는 동안 데이터가 손상될 수 있습니다. 그러나 이 경우, 체크섬 값이 다르게 나온다면, 정확히 같은 값을 기대하는 것과는 달리, 파일에 문제가 있음을 직접적으로 나타냅니다.
		- **파일 포맷이나 인코딩의 변화**: 파일을 다른 시스템으로 전송할 때, 파일 시스템의 차이나 인코딩 방식의 차이로 인해 파일의 내용이 변할 수 있습니다. 이런 변화는 체크섬 값에 영향을 줄 수 있습니다.
		- **환경 설정의 차이**: `sum` 명령어는 시스템의 환경 설정에 따라 다르게 동작할 수 있습니다. 예를 들어, 파일을 읽는 방식이나 처리하는 방식에 차이가 있을 수 있습니다.
	- 개선된 체크섬 알고리즘의 사용 사례에서 볼 수 있는 문제는 주로 *체크섬 계산의 일관성과 관련*된 것입니다. 이러한 일관성의 부재는 데이터의 무결성 검증 과정에서 혼란을 초래할 수 있으며, 정확한 데이터 전송을 확인하는 데 있어서의 신뢰성을 저하시킬 수 있습니다.
	- 따라서, 파일의 무결성을 확인할 때는 가능한 한 같은 시스템, 같은 환경 설정, 그리고 같은 버전의 체크섬 계산 도구를 사용하는 것이 중요합니다.
	  
- **해결 방안 1(chat)** : chat 선생 도움
	- 위와 같은 문제를 해결하기 위해서는 파일의 무결성 검증 과정에서 몇 가지 중요한 점을 고려해야 합니다. 여기 *몇 가지 해결 방안*을 제시합니다:
		- **표준화된 체크섬 도구 사용**: 가능한 한 모든 시스템에서 *동일한 체크섬 계산 도구*와 *버전*을 사용합니다. 예를 들어, `sha256sum` 또는 `md5sum`과 같이 널리 사용되고 표준화된 도구를 선택하여, 모든 시스템에서 일관된 결과를 얻을 수 있도록 합니다.
		- **체크섬 알고리즘 명시**: 파일을 전송하기 전과 전송한 후에 사용된 체크섬 알고리즘을 명시적으로 확인하고 기록합니다. 이 방법은 다른 시스템이나 환경에서도 동일한 알고리즘을 사용하여 체크섬을 계산할 수 있도록 도와줍니다.
		- **데이터 전송 프로토콜의 사용**: 데이터의 무결성을 자동으로 검증할 수 있는 전송 프로토콜을 사용합니다. 예를 들어, `rsync`와 같은 도구는 데이터를 전송하는 동안 무결성 검증을 위한 체크섬을 자동으로 계산하고 확인합니다.
		- **암호학적 체크섬 사용**: 더 높은 수준의 보안과 무결성 검증이 필요한 경우, `SHA-256`이나 `SHA-3`과 같은 암호학적 해시 함수를 사용한 체크섬 계산을 고려할 수 있습니다. 이러한 함수들은 충돌 방지 및 보안 측면에서 더 강력한 보장을 제공합니다.
		- **문서화와 통신**: 데이터를 교환하는 모든 당사자가 사용하는 체크섬 계산 방법과 도구에 대해 명확하게 문서화하고, 이 정보를 공유합니다. 이는 모든 관련자가 데이터의 무결성을 검증하는 데 필요한 동일한 기준을 이해하고 따를 수 있도록 합니다.
	- 이러한 접근 방식은 다양한 시스템과 환경에서 데이터의 무결성을 효과적으로 검증하는 데 도움이 될 수 있습니다.
	- 중요한 것은 데이터의 무결성과 안전성을 확보하기 위해 적절한 도구와 알고리즘을 선택하고, 이를 *일관되게 적용*하는 것입니다.

- **해결 방안 2(book)** : 문제는 개선 자체가 아니라 호환 불가능한 프로그램들의 이름이 같다는 데 있다. 이 변경 때문에 앞으로 오랫동안 우리를 괴롭힐 버전 관리 문제가 생겨버렸다.
	- 그러므로 '*(기능) 명세를 바꾼다면 이름도 바꾸라*'

---

###### 기존 프로그램 및 데이터와 호환성을 유지하라

- **소프트웨어 새 버전 출시 + 예전 버전의 충돌** 
	- 워드 프로세서와 같은 소프트웨어의 *새 버전을 출시*할 때는 *예전 버전에서 생성한 파일도 읽을 수 있게 하는 것이 일반적*이다.
	- 하지만, 때로는 새 버전에서 이전 버전 형식으로 쓰는 기능을 제공하지 못하는 경우가 있다. 
		- *문제 1* : 새 버전 사용자는 새 기능을 사용하지 않더라도 이전 버전을 쓰는 사람들과 파일을 공유할 수가 없다.
		- *문제 2* : 어쩔 수 없이 모든 사람이 업그레이드를 해야한다. 

- **역방향 호환성(backward compatibility)이란?**
	- 어떤 프로그램이 이전 버전의 기능 명세까지 만족시킬 수 있는 능력을 말한다.
		- 어떤 프로그램을 변경하려 한다면 그것에 의존하는 이전 소프트웨어와 데이터를 망가뜨리지 않아야 한다.
		- 변경 내역을 잘 문서화하고, 원래 작동 방식을 복구할 수 있는 방법을 제공해야 한다.
	- 제일 중요한 것은, 지금 하는 변경이 어떤 방식으로든 발생할 수 있는 비호환성이라는 대가에 비교할 때 정말 중요한 개선을 가져오는 것인지 충분히 고려해야한다는 것이다.