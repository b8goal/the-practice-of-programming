## 자주 실수 하는 버그
``` c++
if(x & 1==0)

while ((c == getchar()) != EOF)
	if(c='\n')
		break

for(i=0; i<n; i++);
	a[i++] = 0;

switch (c) {
	case '<' :
		mode = LESS;
		break;
	case '>' :
		mode = GREATER;
		break;
	default :
		mode = EQUAL;
		break;
}
```
### case 1
비트 연산자 `&`는 비교 연산자 `==`보다 낮은 우선순위를 가지므로, `==` 연산이 먼저 수행됩니다. 이로 인해 비트 연산자 `&`의 의도대로 동작하지 않을 수 있습니다.

``` c++
if ((x & 1) == 0)
```
### case 2
어쩌다가 손가락이 미끄러진 경우 = 를 == 로 사용하거나 그 반대의 경우가 있다.
할당시 = , 비교시 ==

`if(c='\n')
이는 항상 참으로 평가되므로 루프가 항상 한 번만 실행되고 종료됩니다.

``` c++
while ((c = getchar()) != EOF) {
    if (c == '\n') {
        break;
    }
}
```
### case 3
편집을 하다가 불필요한 코드를 남겨둘 수 있다.
``` C++
for (i = 0; i < n; i++)
    a[i] = 0;
```
- for 루프 다음 세미콜론을 남겨두면 루프는 빈 루프로 간주된다.
- 배열 `a`의 길이가 `n`이므로 인덱스 `i`는 `0`에서부터 `n-1`까지 유효합니다. 그러나 반복문에서 `i`의 값이 `n`이 되면, `a[i++]`은 `a[n]`에 접근하게 되어 배열 범위를 초과하게 됩니다.
### case 4
잘모르겠습니다....

## 테스트 코드의 버그

``` c++
// 테스트 코드
while (scanf("%s %d", name, &value) !=EOF){
	p = newitem(name, value);
	list1 = addfront(list1, p);
	list2 = addend(list2, p);
}
for (p = list1; p != NULL; p= p->next)
	printf("%s %d\n", p->name, p->value);
```
### 1. **`scanf` 함수의 반환 값 처리
`scanf` 함수는 성공적으로 입력된 변수의 개수를 반환하며, 실패하거나 EOF를 만나면 EOF를 반환합니다. 따라서 위의 코드에서는 `!= EOF`를 사용하는 대신, `!= 2`를 사용하는 것이 더 적절합니다. 왜냐하면 `%s`는 문자열을 성공적으로 읽어야 하므로 반환 값이 2여야 합니다.
``` c++
while (scanf("%s %d", name, &value) != 2)
```
### 2. 메모리 누수 가능성
나중에 리스트를 출력한 후에는 메모리를 해제해야 합니다. 리스트를 해제하지 않으면 메모리 누수가 발생할 수 있습니다.
`freelist(list1);`
위와 같은 방식으로 리스트의 메모리를 해제해야 한다.
여기서 `freelist`는 각 노드를 순회하면서 동적으로 할당된 메모리를 해제하는 함수입니다. `freelist` 함수의 구현은 리스트의 내부 구조에 따라 다를 수 있습니다.
## Intel 펜티엄 FDIV 버그
문제는 펜티엄의 FPU(Floating-Point Unit, 부동소수점 처리 장치)에 있었다.
FPU는 시간이 많이 드는 소수점 계산을 처리함으로써 소프트웨어 속력을 높여주는 장치이다.

팬티엄에는 수치 계산 속력을 높이려고 숫자를 저장해 둔 검색 테이블이 있었는데, 누군가 이 표를 만들면서 한자리에 0을 넣어 버렸다. 즉,

### 123456789123456789

이어야 할 행이

### 123456089123456089

이 되어버렸다.

이처럼 0을 잘못 넣은 탓에, 계산이 소수점 네 자리 이상인 경우 펜티엄은 틀린 답을 내놓았다. 예를 들어, 다음 계산은

5505001/294911=18.6666519735505001/294911=18.666651973 (FPU가 있는 486)

다음과 같은 결과를 내놓았다.

5505001/294911=18.6666000935505001/294911=18.666600093 (펜티엄)

즈음에 회사는 드디어 홍보 마케팅 시스템에서 IPU(Idiot Processing Unit, 바보 처리 장치)를 빼내고 백기를 들었다. 요청하는 고객에게는 무조건 펜티엄 칩을 교환해 주겠다고 약속했고, 문제가 있는 칩은 모두 페기처분 하겠다고 공표했다. 이 모든 난리법석이 진정되기까지 인텔이 입은 손해는 대략 50억 불에 달했다.
