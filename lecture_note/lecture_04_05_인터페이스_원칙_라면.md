# 142p. ~ 145p.

<aside>
📢 *인터페이스는 서비스를 제공하는 코드와 그 서비스를 이용하는 코드 사이에서 정교한 경계선이 된다.*

</aside>

인터페이스가 널리 쓰이기 위해서는…

1. **단순하다.**
2. **범용으로 쓸 수 있다.**
3. **규칙적이다.**
4. **결과를 예상할 수 있다.**
5. **튼튼하다.**
6. **사용자나 기능의 구현 부분이 바뀌면 그에 따라 자연스럽게 바뀌어야 한다.**

### 구현의 세부 사항을 숨겨라

<aside>
📢 *인터페이스 뒤에 존재하는 구현된 코드는 나머지 부분으로부터 숨겨져야 한다.*

</aside>

- 사용자와 관련이 없는, 구현에 관한 내용을 숨겨야 한다.
    - C표준 입출력 라이브러리는 파일 관련 연산들을 제공하는데 실제 파일을 어떤 식으로 읽고 쓰는지에 대한 부분은 FILE* 안에 숨겨져 있다.

- 전역변수 사용을 피해야 한다. 최대한 함수 인자로 데이터를 전달해야 한다.

- **어떤 형태로든 데이터를 공개적으로 열어 젖히지 않을 것을 강력히 권한다.**
    - 사용자가 마음대로 변수를 변경할 수 있다면, 변수 값을 일관성 있게 유지하기가 너무 힘들어지기 때문이다.

### 서로 겹치지 않게 기본 항목들을 선택하라

<aside>
📢 *인터페이스는 딱 필요한 만큼의 기능만 제공해야 하며, 그 기능들이 지나치게 중첩되서는 안된다.*

</aside>

- 폭 넓은 인터페이스는 지향하고 압축적인 인터페이스를 제공해라.
    - 함수가 많은 라이브러리는 사용하기 쉽지만, 대규모 인터페이스는 작성하거나 유지보수하기 어려우며, 그 크기 때문에 배우기도 어렵고 잘 쓰기도 힘들다.

- 같은 일을 수행하는 방법을 여러 개 제공하는 것을 피하자.
    - C의 표준 입출력 라이브러리는 출력 스트림에 문자 한 개를 쓰는 함수를 적어도 네 개 이상 제공한다.
        
        ```c
        char c;
        putc(c, fp);
        fputc(c, fp);
        fprintf(fp, “%c”, c);
        fwrite(&c, sizeof(char), 1, fp);
        ```
        

- 한 가지만 하면서, 제대로 하라.
    - 단지 그렇게 할 수 있다는 이유만으로 인터페이스를 덕지덕지 붙이지 말고, 구현 부분이 문제일 때 인터페이스를 고치지 마라.
    - 예를 들어, 속도가 빠른 memcpy, 안전한 memmove를 따로 만들지 말고, 항상 안전하면서도 때에 따라 빠르기까지 한 함수를 하나만 만드는 편이 나을 것이다.

### 사용자가 모르는 곳에서 일을 꾸미지 마라

<aside>
📢 *라이브러리 함수는 비밀 파일이나 변수를 만들고 쓴다거나 전역 데이터를 변경해선 안 된다. 또한 호출자가 전달한 데이터를 수정하는 일도 삼가야 한다.*

</aside>

- 호출자가 전달한 데이터를 수정하는 일을 삼가야 한다.
    - strtok함수는 입력 문자열 중간에 NULL 바이트를 쓰면서 이를 위반하고 있다.
    - 널 포인터를 쓴다는 것은 호출과 호출 사이에 비밀 데이터가 생긴다는 것을 의미하고, 때문에 버그가 생길 가능성이 높아지며, 또한 이 함수를 동시에 같이 사용할 수가 없게 된다.
    
    ```c
    #define _CRT_SECURE_NO_WARNINGS
    #include <stdio.h>
    #include <string.h>
    
    int main()
    {
        const char* p_str = "Hello~ my friend~~";
        char* p_token_strtok(p_str, " ");
        printf("%s, %s\n", p_str, p_token);
        return 0;
    }
    ```
    

- 단일 인터페이스를 쓸 때, 그 인터페이스 설계자나 구현자의 편의를 위해 또다른 인터페이스를 만들어야 하는 일이 있어서는 안 된다.
    - 단독으로 써도 충분할 정도로 인터페이스를 잘 갖춰 만들든지, 그렇게 못했다면 외부에서 어떤 일을 해줘야 하는지 명시적으로 밝혀라.
    - 그렇지 않으면 유지보수의 책임을 사용자에게 돌리며 C나 C++ 코드에서 거대한 헤더 파일 목록을 관리하는 괴로움을 느끼게 된다.

### 어디에서나 같은 일은 같은 방식으로 처리하라.

<aside>
📢 *일관성과 규칙성은 중요하다.*

</aside>

- 비슷한 것들은 비슷한 수단으로 취해야 한다.
    - C언어 라이브러리의 기본적인 str… 함수들은 따로 문서가 없어도 쓰기 쉬운데 그 이유는 거의 모두 같은 방식으로 작동하기 때문이다.
    - 이와 마찬가지로 STL 컨테이너의 알고리즘은 균일한 인터페이스가 나오도록 구성되어 있으므로 익숙하지 않은 함수라도 사용 방법을 예상하기 편하다.
    - 데이터는 할당문에서와 똑같이 오른쪽에서 왼쪽으로 흐르며, 리턴값은 결과 문자열이다. 인덱스는 대부분 0에서부터 시작한다.
- 외부에 대한 일관성, 즉 다른 것과 비슷하게 작동하는 일관성도 목표가 되어야 한다.
    - C언어에서의 mem… 함수는 str… 함수 이후에 만들어졌지만 스타일을 차용했다.
    - 유닉스의 명령줄 옵션은 모두 - 뒤에 나오지만 같은 옵션 문자라도 다른 프로그램에서는, 심지어 서로 비슷한 프로그램에서도 완전히 다른 의미가 될 수 있다. (그래도 —help만큼은…)

### 마무리

C언어에서는 세부 구현 사항을 숨기는 것이 어렵지만 훌륭한 프로그래머라면 마구잡이로 코딩하지는 않는다. 세부 사항이 인터페이스의 일부가 되면 정보 은닉의 원칙을 위반하기 때문이다. 바람직한 사용법을 강제하기 어려운 상황이라면 헤더 파일에 주석을 달고, 이름을 특수한 형태(__iob처럼)로 쓰거나 하는 방식으로 유도할 수도 있다.

<aside>
📢 *오늘은 최고의 인터페이스라 해도 내일은 문제가 될 수 있다. 하지만 좋은 설계라면 그 ‘내일’이 꽤 오랫동안 오지 않게 할 수 있다.*

</aside>
