# 8 호환성

- 일단 프로그램이 특정 환경에서 잘 돌아간다면, 다른 환경으로 옮길때 처음부터 다시 작성하지 않고 몇가지 작업으로 이식이 가능 한 것을 호환성 이라 한다.

- 왜 호환성을 신경 써야 하는가?
    ----
     - 성공적인 프로그램은 그 정의상 대부분 예상하지 못한 방식으로 예상하지 못한 장소에서 사용되고 한다.
     - 따라서 원 명세보다 더 범용으로 쓸수있게 설계 구축을 해놓으면 유용성은 높아지고 유지보수는 덜 필요해짐.

     - 프로그램은 환경에 의해 변하기 때문에 특정 기능에 의존하는 일이 적을 수록 환경 변화에 더 잘 적응한다.

     - 호환 가능한 프로그램은 설계 구축, 테스트가 잘 어우러져 졌기 때문에 좋은 프로그램이다.

- 세상엔 완전히 호환 가능한 프로그램은 존재치 않는다(?)
    ---
    - 완전히 호환이 되는 프로그램 보다는 충분히 많은 환경에서 테스트해보지 못한 프로그램이 있을 뿐이다.

    - 그래도 많은 환경에서 테스트를 진행해보면 호환성을 어느정도 가질수 있을 것이다.


- 호환성을 위해 노력할것
    -

    - 다양한 표준과 인터페이스, 프로그램이 실행될 환경의 여러 교집합에서 잘 실행 되도록 노력한다.

    - 모든 호환성 문제를 특수 코드를 추가하지 말고 소프트웨어가 새로운 제약 하에서 작동할수 있게 만든다.

    - 어쩔수 없는 비 호환성 코드를 제한하고 제어하기 위해 추상화와 캡슐화 기법을 사용

    - 코드를 제약사항들의 교집합 하에 유지하고 시스템 의존성을 제한하면 그 코드는 더 의미가 분명해지고 다른 환경으로 이식할 때도 더 범용으로 사용할 수 있을 것이다.

 # 8.1 언어

-  표준을 유지하라

    - 호환 가능한 코드를 작성하는 첫 단계는 당연히 프로그램을 고차원 언어로 작성하고 만약 그 언어에 표준이 있다면 그 표준을 유지하는 것이다.

    - 표준에 대해 엄격한 정의는 없다. 
        - 표준은 때로  불완전하기 때문에 기능들이 복잡하게 상호작용할 때의 동작을 정의하지 못한다.
        - 일부러 정의를 확실하게 하지 않는다. -> 제한을 두지 않음으로써 효율적인 구현 가능성을 열어놓고, 하드웨어의 제한을 두지 않는다.
        - 언어는 난해하고, 컴파일러는 복잡하기 때문에 해석에 오류가 생기고 컴파일러에는 버그가 생길수 있다.

    - 가끔은 표준화가 되지 않은 경우도 있다.
        - JAVA는 표준이 아직 없다.

    - 표쥰을 따르지 않는 문법도 있다.
    ``` C++
    ?   *x[] = {"abc"};
    ```
    - 컴파일러 마다 다르지만 x가 char 임을 알 수도 있지만 x 가 int 포인터의 배열이라고도 해석할수 있다.

- 주류를 따라 프로그래밍 하라

    - 이런 에러를 잡지 못하는 컴파일러의 오류는 호환성의 중요한 측면을 보여주는 부분이다. 따라서 코드를 작성할때 이러한 사용은 피하는 것이 좋다.(언어에서의 정의가 모호하지 않고 분명히 이해가 가능하게)

    - 이런 기능 요소는 더 광범위하게 쓰이고 어디서나 똑같은 방식으로 작동하는 경향이 있는데 이것을 언어의 주류(main stream) 이라고 한다.

    - 주류가 무엇인지 아는것은 어렵지만 주류에서 벗어난 것은 알기가 쉽다
        - 어떤 기능요소가 이해하기 어려울 정도로 비일반적이거나 불명로 하면 주류를 벗어난 것이다.
    
    - 이 책은 범용적으로 쓰이는 C와 C++에 대해 논한다.

- C의 주류

    - C언어의 원래 버전은 함수 원형(prototype)을 요구하지 않았다.
    ``` C++
    ?   double sqrt();
    ```
    - 리턴값 타입은 정의, 매개변수 타입을 정의하지 않음
    - ANSI C에서 함수 원형에 대한 부분이 추가
    ``` C++
       double sqrt(double);
    ```
    이렇게 함으로서 더 안전하게 코드를 짤수 있다.

- 언어의 골칫 거리 부분을 인식하라.
    - 표준은 어떤 것을 미정의 상태나 미확정 상태로 남겨놓기도 하는데 이러한 부분은 매우 많다.

- 데이터 타입의 크기
    - C와 C++에서 기본 데이터 타입의 크기는 정의되어있지 않고 아래와 같이 기본적인 원칙만 있다.

    ``` C++
    sizeof(char)<= sizeof(short)<= sizeof(int)<= sizeof(long)<= sizeof(float)<= sizeof(double)
    ```

    -다음과 같은 코드를 통해 컴파일러마다 어떤 값을 표출 하는지 알아볼수 있다.
    ```c++
    int main(void){
        printf("char %d, short %d, int %d, long %d", sizeof(char), sizeof(short), sizeof(int),sizeof(long));
        printf("float %d, double %d, void* %d\n", sizeof(float), sizeof(double),sizeof(void*));
        return 0;
    }
    ```
    ``` c++
    char 1, short 2, int 4, long 4, float 4, double 8, void* 4
    ```
    - 보통은 위와같이 나온다.
    ``` c++
    char 1, short 2, int 4, long 8, float 4, double 8, void* 8
    ```
    - 64비트의 운영체ㅐ제는 다움과 같이 결과가 나온다.
    ``` c++
    char 1, short 2, int 2, long 4, float 4, double 8, void* 2
    ```
    - 초기의 pc는 다음과 같은 결과를 낼것이다.

    - 이와같이 여러종류의 포인터를 지원해서 far과 near 같은 포인터 지시자를 사용했다.

    - 표준 헤더 파일인 stddef.h는 호환성을 지원하는 여러 타입을 정의하고 있다.
    - 이중 가장 흔히 사용되는 타입은 size_t이며 sizeof 연산자가 리턴하는 부호 없는 정수 타입이다.
    - 이러한 경험에서 교훈을 얻은 자바는 모든 기본 데이터 타입의 크기를 정의했다.
    - byte 타입은 8비트, char 타입과 short 타입은 16비트, int 타입은 32비트, long 타입은 64비트이다.
- 계산 순서

    - c와 C++에서 표현식의 피연산자들과 side effect 함수 인자를 계산하는 순서는 정의되있지 않다.

    ```c++
    ?   n = (getchar() << 8 ) | getchar();
    ```
    - 위 할당문은 두번째 항을 먼저 호출할 수도 있다.
    ```c++
    ?   ptr[count] = name[++count];
    ```
    - count 의 증가는 ptr의 인덱스에 쓰이기 전이나 후에 일어날 수 있다.
    ```c++
    ?   printf("%c %c\n", getchar(), getchar());
    ```
    - 위에서 처음으로 입력되는 문자는 처음이 아니라 두 번째로 출력될  수도 있다.

    ``` c++
    ?   printf("%f %s\n", log(-1.23), strerror(errno));
    ```
    - 위에서의 errno의 rkqtdms log함수를 호출하기 전에 계산될 것이다.

    - 이것들과는 다르게 어떤 표현식들은 계산할 때 규칙이 정해져 있다.
    - 정의에 따르면 모든 숨겨진 영향과 함수 호출은 세미콜론이 나올때 또는 함수를 호출하기 전에 완료 되어야 한다.
    - && 와 || 연산자는 왼쪽에서 오른쪽으로 실행되며 진리값을 계산할 수 있을만큼만 연산한다.
    - ? 연산자는 조건을 계산한 다음 뒤에 나오는 표현식 두개중 하나만 계산한다.
    - 자바는 계산 순서를 좀더 엄격하게 정의 한다.
    - 표현식은 숨겨진 영향을 포함해서 왼쪽에서 오른쪽으로 꼐산하게 되어있다.

- char 의 부호
    - c와 C++에서는 Char 데이터 타입에 부호가 붙는지 여부는 정의되지 않는다.
    - 따라서 int값을 리턴하는 getchar()를 호출하면 char 타입과 int 를 결합할때 문제가 발생할수 있다.

    ```c++
    ?       char c; // int 타입 이여야 한다.
    ?       c = getchar();
    ```
    - c는 부호가 없다면 0~255 있다면 -128 ~ 127이 된다.
    - 이걸 배열 인덱스로 사용하거나 stdio에 보통 -1로 지정되어있는 EOF과 일치하는지 검사하게 되면 문제가 발생할 소지가 있다.

    ```c++
    int i;
    char s[MAX];

    for(i = 0 ; i<MAX - 1; i++)
        if((s[i]=getchar()) == '\n' || s[i] == EOF)
            break;
    s[i] = '\0';
    ```
    - getchar 함수가 EOF를 리턴할 때 255(-1을 부호없는 char로 변환시)란 값이 s[i]에 저장된다.
    - s[i]의 타입이 부호없는 char 타입이면 EOF와 비교할때에 255기 때문에 비교 결과는 거짓이 된다.
    - 그러나 부호 있는 char 타입이라해도 이 코드는 틀렸다.
    - 이 비교문은 EOF에서 참이 되어야 하지만 정상적인 입력값인 0XFF를 넣으면 EOF와 똑같아 보이기 때문에 너무 일찍 루프가 끝난다.
    - 따라서 char 타입에 부호가 있는지 여부과 관계없이 EOF와 비교할 때는 getchar 함수의 리턴값을 항상 int 타입으로 저장해야 한다.

    - 따라서 이부분을 호환 가능하게 고친 코드는 다음과 같다.

    ```c++
    int c, i;
    char s[MAX];

    for(i=0; i< MAX -1; i++){
        if( (c = getchar()) == '\n' || c == EOF)
            break;
        s[i] = c;

    }
    s[i]='\0'l
    ```
    - 자바에는 부호 여부가 정의되지 않은 한정자가 없다. 정수 타입에는 부호가 있고 char 타입에는 부호가 없다.

- 산술 시프트와 논리 시프트
    - 연산자로 수행하는 부호있는 값의 오른쪽 시프트 연산은 산술 시프트 아니면 논리 시프트가 된다.
    - 자바는 이를 교훈으로 삼아 >> 연산자를 오른쪽 산술 시프트로 정하고 >>>라는 별도 연산자를 오른쪽 논리 시프트로 예약해 두었다.

- 구조체와 클래스 멤버의 경계정렬 
    - 구조체, 클래스 ,공용체 내부 항목의 경계정렬 방법은 정의되지 않는다.
    - 이런 멤버 변수와 함수들은 선언된 순서대로 배열된다.
    ```c++
    struct X{
        char c;
        int i;
    }
    ```
    - i의 메모리 주소는 이 구조체 처음부터 2나 4 또는 8바이트가 된다.
    - 몇몇 시스템을 int 타입을 딱 맞아 떨어지지 않는 구간에 저장할 수 있게 허용하지만, 대부분이 n바이트 기본 데이터 타입은 n바이트 구간에 저장하도록 한다.

    - 한 예로 보통 8 바이트인 double 타입은 8의 배수로 된 메모리 공간에 저장된다.
    - 컴파일러 제작자가 성능 떄문에 딱 맞아 떨어지는 경계정렬을 강제하는 경우도 있다.

    - 절대로 어떤 구조체의 멤버들이 메모리를 연속적으로 점유한다고 가정해서는 안된다.
    - 구조체의 크기는 내부 멤버 변수들의 합보다 크기 때문이다.

- 비트필드
    - 비트 필드는 시스템 의존성의 너무 크기 때문에 사용해서는 안된다.

- 따라서 아래와같이 규칙 몇개만 따르면 함정을 피해 갈수 있다.
    - char 타입을 EOF와 비교하지 않는다.
    - 타입과 객체의 크기를 계산할 때는 항상 sizeof를 이용한다.
    - 부호 있는 값을 오른쪽 시프트 연산하지 않는다.
    - 데이터 타입의 크기가 거기에 저장하려는 값의 범위보다 큰지 확인한다.

- 여러 컴파일러로 시도하라
    - 컴파일러는 때떄로 사람이 보지 못하는 문제를 발견한다.
    - 서로 다른 컴파일러는 프로그램을 서로 다르게 이해한다.
    - 따라서 여러 컴파일러로 시도해 보고 잘 작동하는지 테스트 해본다.



    

