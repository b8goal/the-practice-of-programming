
# 3장 설계와 구현


``` ad-quote
title: 여러분이  테이블을 감추고 흐름도만 보여준다면 나는 뭐가 뭔지 계속 모를 것이다. 테이블을 보여 달라. 그러면 대개 흐름도는 안봐도 된다. 너무 뻔할 테니까" - 프레드릭 P. 브룩스 주니어
```

- 브룩스에 따르면, 프로그램을 만들 때 가장 중요한 것은 데이터 구조의 설계다.
- 일단 데이터 구조를 만들었다면, 알고리즘은 보통 바로 결정할 수 있고, 그에 따른 코딩도 비교적 쉽다.
- 프로그램의 기본 형태는 다른 프로그램들과 큰 차이가 없다. 즉, 어떤 데이터가 입력으로 들어오고 그 입력에 따라 정교한 작업을 수행한 다음에 결과를 출력하는 구조다.


``` ad-info
title: 우리가 만들 프로그램

- 우리가 만들 프로그램은 그럭저럭 읽을 수 있는 영어 문장을 만들어야 한다.

1) 아무 글자나 단어를 제멋대로 출력하지 않아야 한다.
2) 사전에서 제 멋대로 단어를 선택해서 출력해도 완벽하지 않다.
3) 좀 더 구조화된 통계적 모델이 필요하다. 예를 들면 단어 대신 어구를 단위로 해서, 그 어구의 빈도를 쓰는 것이 좋다.
4) 하나의 예문만 분석하더라도 그 글에서 언어가 쓰인 방식에 대한 통계적 모델을 만들 수 있다.
5) 우리가 만들려는 프로그램은 우리가 입력한 *예문의 통계적 특성을 분석하여 저장하고, 그 특성을 지니는 출력값*을 만드는 프로그램일 것이다.
```

---

# 3.1 마르코프 체인 알고리즘 (Markov chain algorithm)

- 영역이 서로 겹치는 어구가 순서대로 입력된다고 가정해보자.
- 이 알고리즘은 각 어구를 여러 단어로 된 *접두사(Prefix)* 와 한 단어로 이루어진 *접미사(suffix)* 로 나눈다. 
- 그 다음 주어진 접두사에 대해 통계적 특성에 따라 선택된 접미사를 제멋대로 만들어낸다.

``` ad-note
원본 글의 첫 두 단어를 W1과 W2로 잡는다.
W1과 W2를 출력한다.

반복문 :
	- 글에서 접두사 W1 W2를 따라 나오는 단어들 가운데에서 임의로 W3을 선택한다.
	- W3을 출력한다.
	- W1과 W2를 W2와 W3으로 바꾼다.
	- 반복한다.
```

예문 : *Show your flowcharts and conceal your tables and I will be mystified. Show your tables and your flowcharts will be obious. (end)*


|No. |접두사  | 그 접두사 뒤에 나오는 접미사 후보 단어들  |
|-| -|- |
|1.|Show your|flowcharts tables|
|2.|your flowcharts|and will|
||flowcharts and|conceal|
||flowcharts will|be|
||your tables|and and|
|3.|will be|mystified. obvious.|
|4.|be mystified.|Show|
||be obvious.|(end)|
-  위는 입력 단어에서 접두사로 선택된 두 단어와, 그 두 단어 뒤에 접미사로 나온 단어들의 예시이다.

---
## 마르코프 알고리즘은 다음과 같이 작동한다.

1. 먼저 *Show your*를 출력한 다음, *flowcharts*나 tables 중 하나를 출력한다.
2. 만약 flowcharts를 선택했다면 다음 접두사는 *your flowcharts*가 될 것이고,
3. 그 다음 단어는 and 또는 *will* 중 하나가 될 것이다.
4. 이런 방식으로 충분한 길이의 결과가 나왔거나 끝으로 표시해둔 (end)가 나올 때까지 반복한다.

---

## 프로그램 정의
- 우리가 만들 프로그램은 [영어로 된 글 하나]를 읽고 나서, [마르코프 체인 알고리즘]을 써서 [고정된 길이로 된 어구]의 [등장 빈도]에 따라 [새로운 텍스트]를 만들어 낼 것이다.

### 매개변수
- 접두어로 쓸 단어 개수는 [매개변수]로 받는다.
- 보통 영어로 된 글에서는 두 단어를 접두사로 쓰고, 세 번째 단어를 선택하면 괜찮은 성능을 낸다.
### 단어
- 문장부호는 그대로 놔두는 편이 바람직하다. 왜냐하면 문법이 단어를 선택하는데 간접적인 영향을 주게 되어 출력 글의 품질을 높이는 데 도움이 된다.
- *단어*는 공백문자 사이에 들어 있는 모든 것으로 정의한다.
### 결과 예상
- 이 알고리즘에 따르면, 출력문에 나오는 모든 단어, 모든 두 단어 어구, 모든 세 단어 어구는 이미 입력 글에 들어 있는 것들이다.
- 하지만 네 단어 또는 그 이상의 어구들은 알고리즘을 통해 합성된 것도 포함할 것이다.

---
# 3.2 데이터 구조 후보들

- 프로그램이 다루어야 할 입력의 크기는 얼마나 될까?
- 얼마나 빨리 실행되어야 할까?
- 일반적으로 책 한 권 정도 분량을 입력하면 적당할 것이다.
- 따라서 *십만 단어 이상의 입력을 처리*할 수 있도록 프로그램을 만들어야 한다.
- 출력은 수백 또는 수천 개 정도의 단어가 될 것이며
- 분 단위가 아닌 몇 초 수준에서 프로그램 실행이 끝나야 한다.
- 입력에 십만 단어가 들어올 것을 가정했기 때문에, 너무 단순한 알고리즘을 쓰면 프로그램이 느려지므로 조심해야 한다.

---
## 프로그램 실행 방법

- 마르코프 알고리즘은 출력을 만들어 내기 전에 입력 데이터를 다 검토한다.
- 따라서 우리가 만들 프로그램은 전체 입력을 저장해야 한다.

[방법 A] *단어를 가리키는 포인터를 원소로 갖는 배열*을 쓴다면, 출력을 쉽게 만들 수 있다.
- 예컨데, 출력할 단어 하나를 선택하려면, 입력 텍스트를 훑어보고 방금 출력한 접두사에 따라 나올 수 있는 접미사를 찾아보고 그 접미사 중 하나를 골라서 출력하면 된다.
- 하지만 이 방법은 단어 하나를 출력할 때마다 처음의 입력 값을 모두 살펴봐야 하기 때문에 *프로그램이 느려진다*.

[방법 B] *중복되지 않은 단어들만 저장*하고 입력 글에서 이 *단어가 쓰인 곳을 리스트로 기록*하는 방식이 있다.
- 한 단어 뒤에 나오는 접미사를 빠르게 찾을 수 있다.
- 해시 테이블은 '주어진 접두사 뒤에 올 수 있는 모든 접미사를 빠르게 찾아야 한다'를 바로 충족하지 못하므로,
- 한 접두사와 여기에 딸린 여러 접미사를 표현해 주는 *데이터 구조*가 필요하다.

---
## 프로그램 실행 단계

- **1단계** : 입력을 읽고 어구를 표현하는 데이터 구조를 만들어 내는 단계
	- *접두사*를 찾아서 이 접두사 다음으로 올 수 있는 *접미사*를 등록
		- 한 접두사가 주어졌다면, 나중에 접근할 수 있도록 그 접두사를 따라 나오는 모든 접미사들을 저장해야 한다.
		- 접미사들은 정렬해서 저장할 필요가 없으며,
		- 한 번에 하나씩 추가 된다.
		- 얼마나 많은 접미사가 있을지 미리 알 수 없으므로, 데이터 구조는 쉽고 효율적으로 크기를 키울 수 있어야 한다.
		- 따라서 리스트나 동적 배열이 적당한 데이터 구조가 된다.
		- 나중에 출력할 때 원하는 접두사에 딸린 접미사 중 하나를 아무렇게나 선택할 수 있어야한다.
		- 그리고 추가된 항목을 삭제하는 기능은 필요 없다.
	- *1단계 정리* : 접두사 단어를 키[key]로 쓰고, 접미사 목록을 값[value]으로 한 *해시 테이블*이 필요하다.
		- 한 접두사와 이에 딸린 여러 접미사를 상태[state]라고 부른다.
		- 각 상태는 한 접두사와 여러 접미사로 구성된다. 
		- 이 정보는 해시 테이블에 저장할 것이며, 이 때 키[key]는 접두사가 된다.
		- 각 접두사는 고정 개수의 단어로 구성되며,
		- 주어진 접미사가 한 번 이상 나왔을 경우에도 리스트에 중복해서 추가한다.
- **2단계** : 이 데이터 구조를 써서 제멋대로 글을 만들어 내는 단계 
	- 해당 *접두사*를 찾아서 그에 딸린 *접미사*를 얻는다.
- **결론** : 주어진 접두사를 빨리 찾아보는 것은 두 단계에 모두 꼭 필요하다.

``` ad-info
title: 어떤 어구가 두 번 이상 등장한다며 어떻게 해야 할까?
예를 들어, 입력 글에서 'might appear twice'는 두 번 등장하지만 'might appear once'는 한번만 등장한다고 해보자
이런 정보는 'might appear'의 접미사 리스트에 'twice'를 두 번 넣거나 한 번만 추가하는 대신
접미사마다 카운터를 두고 그 숫자를 2로 맞추는 방법을 쓸 수 있다.
```

``` ad-question
title: 다음으로, 단어를 어떻게 표현할지 결정해야 한다.
가장 쉬운 방법은 각 단어를 *독립된 문자열로 저장*하는 것이다.
하지만, 입력 글에서 같은 단어가 중복해서 나오는 경우가 많기 때문에,
단어를 저장하는 *두 번째 해시 테이블*을 만들고 각 단어가 한 번만 저장되도록 한다면 메모리를 절약할 수 있다.
이 방식을 쓰면 접두사 해시 값도 빨리 계산할 수 있다.
왜냐하면 문자열마다 고유한 주소를 갖기 때문에, 문자열을 구성하는 각 글자를 비교하는 대신 포인터 값을 직접 비교할 수 있기 때문이다.
이 글에서는 이 방식이 아닌, 좀 더 간단하게 문자열을 독립적으로 저장하는 방식을 쓸 것이다.
대신 이 방식을 설계하는 것은 연습문제로 남긴다.
```

---
# 3.5 자바

- 자바와 같은 객체 지향 언어를 쓸 때에는 컴포넌트 사이의 *인터페이스*에 관심을 기울여야 한다.
- 이 컴포넌트들은 캡슐화되어 *독립적인 데이터 항목*이 되는데, *오브젝트* 또는 *클래스*라고 부른다.
- 그리고 이 오브젝트 또는 클래스에 관한 *연산 함수는 메서드*라고 부른다.

``` ad-info
title: 마르코프 알고리즘(Markov algorithm)은 무엇인가? 

마르코프 알고리즘(Markov algorithm)은 문자열 조작을 위한 규칙 기반의 알고리즘입니다. 이 알고리즘은 문자열 위에서 규칙을 순차적으로 적용하여 문자열을 변환하는 데 사용됩니다. 마르코프 알고리즘의 주요 특징과 작동 방식은 다음과 같습니다:

1. **규칙 기반**: 마르코프 알고리즘은 규칙의 목록으로 구성됩니다. 각 규칙은 "패턴 -> 치환"의 형태로 주어지며, 이는 문자열 내의 특정 패턴을 찾아 해당 패턴을 다른 문자열로 치환하라는 의미입니다.
    
2. **순차적 적용**: 규칙은 주어진 순서대로 적용됩니다. 첫 번째 규칙부터 시작하여 문자열에 적용할 수 있는 규칙을 찾을 때까지 목록을 순회합니다.
    
3. **종료 조건**: 문자열에 더 이상 적용할 수 있는 규칙이 없을 때 알고리즘은 종료됩니다.
    
4. **비결정적**: 동일한 입력 문자열에 대해 여러 결과가 생성될 수 있습니다. 이는 규칙의 순서나 규칙 자체에 따라 다르게 될 수 있습니다.
    

마르코프 알고리즘은 다양한 문자열 처리 작업에 사용될 수 있으며, 특히 언어 변환, 코드 최적화, 그래픽 패턴 인식 등의 분야에서 활용됩니다.
```

``` ad-example
title: 자바는 C보다 라이브러리가 풍부해서, 여러 오브젝트를 다양한 방법으로 관리하기 위한 '컨테이너 클래스'들도 제공한다.
예를 들어, Vector는 모든 오브젝트 타입을 저장할 수 있는, 크기가 동적으로 배열하는 클래스다. 
또, 해시 테이블은 오브젝트를 키로 써서 다른 테이터 타입의 값을 저장하거나 꺼내올 수 있다.
```

``` ad-note
title: 우리가 만들 프로그램 (JAVA)
```

- 문자열(접두사, 접미사)을 저장하기 위해 *Vector*를 사용한다.
- 접두사 Vector를 *키(Key)* 로 하고, 접미사 Vector를 *값(Value)* 로 하는 *해시 테이블*을 사용한다 : 이런 작업을 '매핑(mapping)'이라고 한다.
- C 언어에서와 달리 State 타입을 따로 만들 필요가 없는 이유는 해시 테이블이 내부적으로 접두사와 접미사를 연결해서 관리하기 때문이다.
 
***해시 테이블***은 [접두사 key- 접미사 value 쌍]을 저장하는 *put 메서드*와 [값 (접미사 value)]을 가져오는 *get 메서드*를 제공한다.
``` java
	Hashtable h = new Hashtable();
	h.put(key, value);
	Sometype v = (Sometype) h.get(key);
```

---
## 이제 세 개의 클래스를 만들어야 한다. 

첫번째로, 접두사를 구성하는 단어를 저장할 ***Prefix 클래스***를 만들어보자.
``` java
	class Prefix {
		public Vector pref; // 입력에서 서로 붙어 있는 NPREF 개의 단어들
	...
```

두번째 클래스는 입력을 읽어 해시 테이블을 만들고 출력을 생성하는 ***Chain 클래스***다. 아래에서 이 클래스의 변수 부분을 볼 수 있다.
``` java
	class Chain {
		static final int NPREF = 2; // 접두사 크기
		static final String NONWORD = "\n"; // 등장할 수 없는 '단어'
		Hashtable statetab = new Hashtable(); // key = Prefix, value = 접미사인 Vector
		Prefix prefix = new Prefix(NPREF, NONWORD); // 최초 접두사
		Random rand = new Random();
		...
```

세번째 클래스는 main을 포함하고 Chain을 실제로 만들어 주는 ***퍼블릭 인터페이스 부분***이다.
```java
	class Markov {
		static final int MAXGEN = 10000; // 생성할 수 있는 최대 단어 수
		public static void main(String[] args) throws IOException
		{
			chain chain = new Chain();
			int nwords = MAXGEN;
			
			chain.build(System.in);
			chain.generate(nwords);
		}
	}
```
 Chain 클래스의 인스턴스가 생성되면, 다시 그 인스턴스가 해시 테이블을 만들고 최초 접두사를 NPREF 개의 NONWORD로 채운다.

---

***build 함수***는 공백문자로 분리된 단어들로 입력을 파싱하기 위해 라이브러리 함수 *StreamTokenizer*를 사용한다.
아래 코드에서 반복문 위의 세 문장은 단어를 분리해 주는 *tokenizer*를 우리가 원하는 단어의 정의에 맞게 설정하는 부분이다.
``` java
	// Chain build: 입력 스트림에서 State 테이블을 생성
	void build(InputStream in) throws IOException
	{
		StreamTokenizer st = new StreamTokenizer(in);
		
		st.resetSyntax(); // 기본 규칙 모두 제거
		st.wordChars (0, Charactor.MAX_VALUE); // 모든 글자를 다 일반 글자로 설정
		st.whitespaceChars(0, ' '); // 공백문자만 제외
		while (st.nextToken() != st.TT_EOF)
			add(st.sval);
		add(NONWORD);
	}

```

---

***add 함수***는 현재 접두사에 해당하는 접미사 벡터를 *해시 테이블*에서 가져온다.
이 때 접미사가 하나도 없다면(suf가 null일 경우), add는 해시 테이블에 저장하기 위한 *새로운 벡터와 새로운 접두사*를 만든다.
이 두 경우 모두 add는 새 단어를 접미사 벡터에 추가하고, 접두사에서 첫번째 단어를 제거하고 새 단어 끝에 넣음으로써 접두사를 전진시킨다.
``` java
	void add(String word)
	{
		Vector suf = (Vector) statetab.get(prefix);
		if (suf == null) {
			 suf = new Vector();
			 statetab.put(new Prefix(prefix), suf); // 주의
		 }
		 suf.addElement(word);
		 prefix.pref.removeElementAt(0);
		 prefix.pref.addElement(word);
	}
```

suf가 null일 경우 add가 해시 테이블에 넣는 것이 prefix 자체가 아니라 *새로운 Prefix 오브젝트*라는 것에 주의하기 바란다.
그 이유는 해시 테이블 클래스가 레퍼런스로 항목을 저장하기 때문이다.

---

**generate 함수**는 C 언어와 비슷하지만 좀 더 간단하게 만들 수 있다. 왜냐하면, 자바는 반복문을 써서 리스트를 훑어보는 대신 *인덱스*를 써서 벡터의 항목에 접근할 수 있기 때문이다.
``` java
	// Chain generate: 단어들을 만들고 출력
	void generate(int nwords)
	{
		prefix = new Prefix(NPREF, NONWORD);
		for (int i = 0; i < nwords; i++){
			Vector s = (Vector) statetab.get(prefix);
			int r = rand.nextInt(s.size());
			String suf = (String) s.elementAt(r);
			if (suf.equals(NONWORD))
				break;
			System.out.printIn(suf);
			prefix.pref.removeElementAt(0);
			Prefix.pref.addElement(suf);
		}
	}
```

---

아래 코드에서 ***Prefix의 두 생성자***는 제공받은 데이터를 써서 *새로운 인스턴스*를 만든다.
*첫 번째 생성자*는 기존 Prefix의 복사본을 만들며, 두 번째 생성자는 동일한 문자열을 n개 가지는 접두사를 만든다. 
*두 번째 생성자*는 초기 접두사를 만들 때 NONWORD를 NPREF개만큼 만들기 위해 사용된다.
``` java
	// Prefix 생성자: 기존 Prefix를 복제
	Prefix(Prefix p)
	{
		pref = (Vector) p.pref.clone();
	}
	
	// Prefix 생성자: str을 n번 복사
	Prefix(int n, String str)
	{
		pref = new Vector();
		for (int i = 0; i < n; i++)
			pref.addElement(str);
	}
```

---

*Prefix*는 ***hashCode와 equals 메서드***를 가진다. 이 둘은 *해시 테이블이 테이블을 인덱싱하고 검색할 때 쓰는 메서드*다.
해시 테이블에 알려주기 위한 두 메서드를 만들려면 독립적인 클래스가 필요한데, 바로 이것이 접미사처럼 그냥 Vetor를 쓰지않고 *Prefix란 클래스를 따로 만든 이유*다.

*Prefix*의 **hashCode 메서드**는 벡터에 들어 있는 원소들의 해시 코드를 합해서 단 하나의 해시 값으로 만들어 준다.
```java
	static final int MULTIPLIER = 31; // hashCode() 용
	
	// Prefix hashCode: 접두사를 구성하는 단어들에서 해시 값을 생성
	public int hashCode()
	{
		int h = 0;
		
		for (int i = 0; i < pref.size(); i++)
			h = MULTIPLER * h + pref.elementAt(i).hashCode();
		return h;
	}
```

그리고 아래 **equals**는 두 접두사에 들어 있는 단어들을 단어 단위로 비교한다.
```java
	// Prefix equals: 두 접두사에 동일한 단어들이 들어 있는지 비교
	public boolean equals(Object o)
	{
		Prefix p = (Prefix) o;
		for (int i = 0; i < pref.size(); i++)
			if (!pref.elementAt(i).equals(p.pref.elementAt(i)))
				return false;
		return true;
	}
```

---
## 자바로 짠 프로그램은 C로 만든 프로그램보다 크기가 매우 작으며, 세부사항도 많지 않다.
- 그 이유는 라이브러리가 제공하는 *Vector와 해시 테이블을 쓰기 때문*이다.
- 필요할 때 알아서 크기가 변하는 *Vector* 덕택에 메모리 관리가 매우 쉬워지며, *가비지 컬랙션* 덕택에 따로 메모리를 해제하지 않아도 된다.
- 하지만, 자바가 모든 것을 알아서 해주는 것은 아니다. 따라서 해시 테이블을 쓰기 위해 따로 hashCode와 equals를 만들어 주는 수고가 필요하다.
  
---
## 자바 VS C 

*자바*는 *기능이 더 잘 분할 되어있다.*
- 자바 프로그램에서 Vector를 배열로 바꾸는 것은 매우 쉽게 해결할 수 있다.
- C 프로그램에서는 모든 부분이 자기 말고 다른 부분들이 무슨 일을 하는지 죄다 알고 있다.
	- 해시 테이블은 다양한 장소에서 사용되는 배열들을 대상으로 실행
	- lookup 함수는 State와 Suffix 구조체의 내부 구조를 알며, 누구나 접두사 배열의 크기를 알고 있다.
